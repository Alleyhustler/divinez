<!DOCTYPE html><html lang="en" style="cursor: default;"><head style="cursor: default;">
    <meta charset="UTF-8" style="cursor: default;">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" style="cursor: default;">
    <title style="cursor: default;">PYSION | FRAMEWORK</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&display=swap" style="cursor: default;">
    <link rel="stylesheet" href="css/atom-one-dark.min.css" style="cursor: default;">
    <script src="js/highlight.min.js" style="cursor: default;"></script>
    <script src="js/loader.js" style="cursor: default;"></script>
    <link rel="stylesheet" href="css/all.min.css" style="cursor: default;">
    <link rel="icon" type="image/png" href="images/alone.png" style="cursor: default;">
    <style style="cursor: default;">
        :root {
            --black: #000000;
            --white: #ffffff;
            --gray: #808080;
            --dark-gray: #1a1a1a;
            --spacing: 6rem;
            --transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Chakra Petch', monospace;
        }

        body {
            background: var(--black);
            color: var(--white);
            min-height: 100vh;
            overflow-y: scroll;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Header */
        .header {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 1rem;
            padding: 2rem;
            position: relative;
            overflow: hidden;
        }

        .logo {
            width: 80px;
            height: 80px;
            margin-bottom: 2rem;
            animation: pulse 2s infinite ease-in-out;
            transition: var(--transition);
        }

        .logo:hover {
            animation: rotate 4s infinite linear;
        }

        .title {
            font-size: 4rem;
            font-weight: 700;
            letter-spacing: 0.2em;
            text-align: center;
            animation: fadeIn 1s ease-out;
            position: relative;
        }

        .title:hover {
            animation: glitch 0.3s infinite;
        }

        .subtitle {
            color: var(--gray);
            font-size: 1.5rem;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            animation: fadeIn 1s ease-out 0.3s backwards;
        }

        /* Navigation */
        .nav {
            position: fixed;
            top: var(--spacing);
            left: var(--spacing);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            z-index: 100;
            animation: fadeIn 1s ease-out 0.6s backwards;
            transition: opacity 0.3s ease, pointer-events 0.3s ease;
        }

        .nav-link {
            color: var(--gray);
            text-decoration: none;
            font-size: 0.9rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            transition: var(--transition);
            position: relative;
            padding: 0.5rem 1rem;
        }

        .nav-link::before {
            content: '';
            position: absolute;
            left: 0;
            bottom: 0;
            width: 0;
            height: 1px;
            background: var(--white);
            transition: var(--transition);
        }

        .nav-link:hover {
            color: var(--white);
        }

        .nav-link:hover::before {
            width: 100%;
        }

        /* Main Content */
        .content {
            padding: var(--spacing);
            max-width: 1200px;
            margin: 0 auto;
        }

        .section {
            margin-bottom: calc(var(--spacing) * 2);
            opacity: 0;
            transform: translateY(20px);
            transition: var(--transition);
        }

        .section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .section-title {
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            margin-bottom: 2rem;
            position: relative;
            display: inline-block;
        }

        .section-title::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: -10px;
            width: 50%;
            height: 2px;
            background: var(--white);
            transition: var(--transition);
        }

        .section-title:hover::after {
            width: 100%;
        }

        /* Code Display */
        .code-container {
            background: var(--dark-gray);
            padding: 2rem;
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
            transition: var(--transition);
            border: 1px solid transparent;
        }

        .code-container:hover {
            border-color: var(--white);
            transform: scale(1.01);
        }

        .code-header {
            position: absolute;
            top: 1rem;
            right: 1rem;
            color: var(--gray);
            font-size: 0.8rem;
            letter-spacing: 0.1em;
        }

        code {
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--white);
            display: block;
        }

        /* Feature Grid */
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 4rem;
        }

        .feature-card {
            border: 1px solid var(--gray);
            padding: 2rem;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            background: var(--dark-gray);
            animation: float 6s infinite ease-in-out;
        }

        .feature-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: translateX(-100%);
            transition: var(--transition);
        }

        .feature-card:hover {
            transform: translateY(-5px);
            border-color: var(--white);
        }

        .feature-card:hover::before {
            transform: translateX(100%);
        }

        .feature-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            letter-spacing: 0.1em;
        }

        .feature-description {
            color: var(--gray);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Geometric Decorations */
        .geometric {
            position: absolute;
            opacity: 0.1;
            pointer-events: none;
            transition: var(--transition);
        }

        .geometric-1 {
            top: 10%;
            right: 10%;
            width: 200px;
            height: 200px;
            border: 2px solid var(--white);
            transform: rotate(45deg);
            animation: rotate 20s infinite linear;
        }

        .geometric-2 {
            bottom: 10%;
            left: 10%;
            width: 150px;
            height: 150px;
            border: 2px solid var(--white);
            transform: rotate(30deg);
            animation: rotate 15s infinite linear reverse;
        }

        /* Custom Cursor */
        .cursor {
            width: 20px;
            height: 20px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: difference;
            transition: all 0.1s ease;
            transition-property: width, height, border;
        }

        .cursor-follower {
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: difference;
            transition: transform 0.1s ease;
        }

        /* Cursor hover effects */
        .cursor.active {
            width: 40px;
            height: 40px;
            border-width: 2px;
        }

        .cursor-follower.active {
            transform: scale(0.3);
        }

        /* Hide default cursor */
        * {
            cursor: none !important;
        }

        a, button {
            cursor: none;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root {
                --spacing: 2rem;
            }

            .title {
                font-size: 2.5rem;
            }

            .subtitle {
                font-size: 1rem;
            }

            .nav {
                position: static;
                padding: 2rem;
            }

            .cursor, .cursor-follower {
                display: none;
            }
        }

        /* Documentation Layout - Increased spacing */
        .docs-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 2rem;
            margin-top: calc(100vh + 8rem); /* Increased margin from top */
            background: var(--black);
            position: relative;
            z-index: 2;
        }

        /* Sidebar Styling */
        .docs-sidebar {
            padding: 2rem;
            background: var(--black);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            height: 100vh;
            overflow-y: auto;
            position: sticky;
            top: 0;
        }

        /* Remove any pseudo-elements that might be causing the blur */
        .docs-sidebar::before,
        .docs-sidebar::after {
            display: none;
        }

        /* Ensure clean bottom of sidebar */
        .docs-sidebar > *:last-child {
            margin-bottom: 2rem;
        }

        /* Search Input */
        .search-container {
            position: relative;
            margin-bottom: 2rem;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: var(--white);
            font-family: 'Chakra Petch', monospace;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--white);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
        }

        /* Enhanced Search Results Styling */
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 0.5rem;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .search-result-item {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            animation: slideIn 0.3s ease forwards;
            position: relative;
            overflow: hidden;
        }

        .search-result-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(180deg, transparent, var(--white), transparent);
            transform: scaleY(0);
            transition: transform 0.3s ease;
        }

        .search-result-item:hover::before {
            transform: scaleY(1);
        }

        .search-result-item:hover {
            background: rgba(255, 255, 255, 0.05);
            transform: translateX(5px);
        }

        .search-result-title {
            color: var(--white);
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .search-result-preview {
            color: var(--gray);
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .search-highlight {
            color: var(--white);
            background: rgba(255, 255, 255, 0.1);
            padding: 0.1em 0.3em;
            border-radius: 2px;
            animation: glow 1.5s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 5px rgba(255, 255, 255, 0.1),
                            0 0 10px rgba(255, 255, 255, 0.1),
                            0 0 15px rgba(255, 255, 255, 0.1);
            }
            to {
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.2),
                            0 0 20px rgba(255, 255, 255, 0.2),
                            0 0 30px rgba(255, 255, 255, 0.2);
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Version Selector */
        .version-select {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--black);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: var(--gray);
            font-family: 'Chakra Petch', monospace;
            margin: 1rem 0;
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed !important;
        }

        /* Documentation Navigation */
        .docs-section-title {
            color: var(--gray);
            text-transform: uppercase;
            font-size: 0.8rem;
            margin: 2rem 0 1rem;
            letter-spacing: 0.2em;
            position: relative;
            padding-left: 1rem;
        }

        .docs-section-title::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            width: 4px;
            height: 4px;
            background: var(--white);
            transform: translateY(-50%);
        }

        .docs-link {
            display: block;
            color: var(--gray);
            text-decoration: none;
            padding: 0.5rem 1rem;
            margin: 0.25rem 0;
            transition: all 0.3s ease;
            border-left: 2px solid transparent;
            letter-spacing: 0.1em;
        }

        .docs-link:hover,
        .docs-link.active {
            color: var(--white);
            background: rgba(255, 255, 255, 0.05);
            border-left-color: var(--white);
            transform: translateX(5px);
        }

        /* Main Content */
        .docs-content {
            padding: 3rem 4rem;
            background: var(--black);
            color: var(--white);
            min-height: 100vh;
            position: relative;
            overflow-y: scroll;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        .docs-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        }

        .docs-title {
            font-size: 3rem;
            margin-bottom: 1rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            position: relative;
            display: inline-block;
        }

        .docs-title::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: -10px;
            width: 60%;
            height: 2px;
            background: var(--white);
            transition: width 0.3s ease;
        }

        .docs-title:hover::after {
            width: 100%;
        }

        .docs-description {
            color: var(--gray);
            font-size: 1.2rem;
            margin-bottom: 3rem;
            letter-spacing: 0.05em;
            line-height: 1.6;
        }

        /* Code Blocks */
        .code-example {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .code-example:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .code-example pre {
            margin: 0;
            padding: 1.5rem;
        }

        .code-example code {
            font-family: 'Chakra Petch', monospace;
            color: var(--gray);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Feature Grid */
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .feature-item {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .feature-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.03), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .feature-item:hover {
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.2);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .feature-item:hover::before {
            transform: translateX(100%);
        }

        .feature-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            letter-spacing: 0.1em;
        }

        .feature-description {
            color: var(--gray);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Add these styles for search results */
        .search-no-results {
            padding: 1rem;
            text-align: center;
        }

        .tech-stack {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .tech-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .tech-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }

        .tech-item h3 {
            color: var(--white);
            margin-bottom: 1rem;
        }

        .tech-item p {
            color: var(--gray);
            line-height: 1.6;
        }

        .code-example {
            position: relative;
            overflow: hidden;
        }

        .code-example::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 30px;
            height: 100%;
            background: linear-gradient(to right, transparent, var(--black));
        }

        .system-diagram,
        .vector-space-diagram,
        .memory-diagram,
        .state-diagram {
            width: 100%;
            height: 600px !important; /* Force the height */
            padding: 3rem;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            margin: 2rem 0;
            position: relative;
        }

        .system-diagram svg,
        .vector-space-diagram svg,
        .memory-diagram svg,
        .state-diagram svg {
            width: 100%;
            height: 100% !important; /* Force the height */
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .diagram-legend {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            color: var(--gray);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--gray);
        }

        .memory-layers {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .memory-layer {
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .memory-layer h4 {
            color: var(--white);
            margin-bottom: 1rem;
        }

        .memory-layer p, .memory-layer ul {
            color: var(--gray);
        }

        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .metric-card {
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            text-align: center;
        }

        .metric .number {
            font-size: 2rem;
            font-weight: bold;
            color: var(--white);
        }

        .metric .unit {
            font-size: 0.9rem;
            color: var(--gray);
        }

        .diagram-caption {
            text-align: center;
            color: var(--gray);
            margin-top: 1.5rem;
            font-size: 0.9rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Ensure text remains crisp */
        svg text {
            font-family: inherit;
            font-weight: 500;
        }

        .system-diagram h3,
        .vector-space-diagram h3,
        .memory-diagram h3,
        .state-diagram h3 {
            position: relative;
            z-index: 1;
            margin-bottom: 2rem;
            color: rgba(255,255,255,0.95);
            font-family: 'Chakra Petch', monospace;
            font-size: 1.5rem;
            text-align: center;
        }

        .system-diagram .diagram-caption,
        .vector-space-diagram .diagram-caption,
        .memory-diagram .diagram-caption,
        .state-diagram .diagram-caption {
            text-align: center;
            color: var(--gray);
            margin-top: 1.5rem;
            font-size: 0.9rem;
            font-family: 'Chakra Petch', monospace;
        }

        .vector-diagram {
            width: 100%;
            height: 100%;
            min-height: 600px;
            padding: 3rem;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            margin: 2rem 0;
        }

        .vector-diagram svg {
            width: 100%;
            height: 100%;
            min-height: 600px;
        }

        .vector-diagram h3 {
            color: rgba(255,255,255,0.95);
            margin-bottom: 2.5rem;
            font-family: 'Chakra Petch', monospace;
            font-size: 1.5rem;
            text-align: center;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }

        /* Add this to ensure the docs container overlaps properly */
        .docs-container {
            background: #000;
            padding-top: 80px; /* Increased padding further */
        }

        /* Add styles for main nav links */
        .main-nav-link {
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .main-nav-link.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .quantum-field {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background: #000;
        }

        .quantum-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Add these new styles without removing anything */
        @keyframes highlightFade {
            0% {
                background: rgba(255, 255, 255, 0.3);
                color: #fff;
            }
            100% {
                background: transparent;
                color: inherit;
            }
        }

        .search-highlight-result {
            position: relative;
            background: none;
        }

        .search-highlight-result::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -4px;
            right: -4px;
            bottom: -2px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            animation: highlightPulse 2s ease-out forwards;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        @keyframes highlightPulse {
            0% {
                opacity: 0;
                transform: scale(0.95);
            }
            20% {
                opacity: 1;
                transform: scale(1.05);
            }
            40% {
                transform: scale(1);
            }
            80% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: scale(1);
            }
        }

        /* Typography Enhancements */
        .docs-content h1, 
        .docs-content h2, 
        .docs-content h3 {
            font-family: 'Chakra Petch', monospace;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            line-height: 1.4;
            background: linear-gradient(90deg, var(--white), rgba(255, 255, 255, 0.8));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
            display: inline-block;
        }

        .docs-content h1 {
            font-size: 3.5rem;
            margin: 3rem 0 2rem;
            font-weight: 700;
        }

        .docs-content h2 {
            font-size: 2.2rem;
            margin: 2.5rem 0 1.5rem;
            font-weight: 600;
        }

        .docs-content h3 {
            font-size: 1.8rem;
            margin: 2rem 0 1rem;
            font-weight: 600;
        }

        .docs-content p {
            font-family: 'Chakra Petch', monospace;
            font-size: 1.1rem;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.7);
            margin: 1.2rem 0;
            letter-spacing: 0.02em;
            font-weight: 400;
        }

        .docs-content p strong {
            color: var(--white);
            font-weight: 500;
            position: relative;
            padding: 0 0.2em;
        }

        .docs-content p strong::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .docs-content p strong:hover::before {
            transform: scaleX(1);
        }

        .docs-content ul,
        .docs-content ol {
            margin: 1.5rem 0;
            padding-left: 1.5rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .docs-content li {
            margin: 0.8rem 0;
            line-height: 1.6;
            position: relative;
            font-weight: 400;
        }

        .docs-content li::before {
            content: '›';
            position: absolute;
            left: -1.2rem;
            color: rgba(255, 255, 255, 0.4);
            font-size: 1.2em;
            transition: color 0.3s ease;
        }

        .docs-content li:hover::before {
            color: var(--white);
        }

        .docs-description {
            font-size: 1.4rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.6);
            margin: 2rem 0 3rem;
            letter-spacing: 0.03em;
            max-width: 800px;
            position: relative;
            padding-left: 1.5rem;
            border-left: 2px solid rgba(255, 255, 255, 0.1);
            transition: border-left-color 0.3s ease;
            font-weight: 400;
        }

        .docs-description:hover {
            border-left-color: rgba(255, 255, 255, 0.4);
        }

        /* Code block text enhancements */
        .code-example code {
            font-family: 'Chakra Petch', monospace;
            font-size: 1rem;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.9);
        }

        /* Feature item text enhancements */
        .feature-item h3 {
            font-size: 1.4rem;
            margin-bottom: 1.2rem;
            letter-spacing: 0.1em;
            background: linear-gradient(90deg, var(--white), rgba(255, 255, 255, 0.8));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .feature-item ul {
            list-style: none;
            padding: 0;
        }

        .feature-item li {
            margin: 1rem 0;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.1rem;
            letter-spacing: 0.02em;
            line-height: 1.6;
            padding-left: 1.5rem;
            position: relative;
            font-weight: 400;
        }

        .feature-item li::before {
            content: '›';
            position: absolute;
            left: 0;
            color: rgba(255, 255, 255, 0.4);
            transition: color 0.3s ease, transform 0.3s ease;
        }

        .feature-item li:hover::before {
            color: var(--white);
            transform: translateX(3px);
        }

        .feature-item strong {
            color: var(--white);
            font-weight: 500;
            position: relative;
        }

        .feature-item strong::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            bottom: -2px;
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .feature-item strong:hover::after {
            transform: scaleX(1);
        }

        /* Section transitions */
        .api-section {
            opacity: 0;
            transform: translateY(20px);
            animation: sectionFadeIn 0.6s ease forwards;
        }

        @keyframes sectionFadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Scroll Indicator */
        .scroll-indicator-container {
            position: fixed;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .scroll-progress {
            width: 2px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .scroll-progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: var(--white);
            transition: height 0.1s ease;
        }

        .scroll-marker {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--white);
            position: absolute;
            left: -3px;
            transition: top 0.1s ease;
        }

        .scroll-label {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin: 1rem 0;
            transition: color 0.3s ease;
        }

        .scroll-label:hover {
            color: var(--white);
        }

        /* Larger VAE Logo */
        .vae-logo {
            width: 600px; /* Increased from 400px */
            height: auto;
            margin-bottom: 3rem;
            filter: drop-shadow(0 0 20px rgba(255,255,255,0.2));
        }

        .vae-logo img {
            width: 100%;
            height: auto;
            object-fit: contain;
        }

        /* Adjust framework content spacing */
        .framework-content {
            position: relative;
            z-index: 2;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Add these styles to your existing CSS */
        .roadmap-button {
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            padding: 8px 16px;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            font-family: 'Chakra Petch', sans-serif;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .roadmap-button:hover {
            color: rgba(255, 255, 255, 0.9);
            background: rgba(255, 255, 255, 0.05);
        }

        /* Roadmap styles - complete redesign */
        .roadmap-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: linear-gradient(to bottom right, rgba(0, 0, 0, 0.97), rgba(0, 0, 0, 0.95));
            z-index: 1000;
            backdrop-filter: blur(20px);
            overflow-y: auto;
            padding: 40px 20px;
            overflow-y: scroll;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        .roadmap-content {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(20, 20, 25, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 60px;
            box-shadow: 0 20px 80px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .roadmap-header {
            text-align: center;
            margin-bottom: 60px;
            position: relative;
        }

        .roadmap-header h1 {
            font-size: 42px;
            background: linear-gradient(45deg, #fff, #a8b2ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            font-family: 'Chakra Petch', monospace;
            letter-spacing: 2px;
        }

        .roadmap-header p {
            color: rgba(255, 255, 255, 0.7);
            font-size: 18px;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .milestone {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .milestone:hover {
            transform: translateY(-4px) scale(1.01);
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.15);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
        }

        .milestone::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, #4f46e5, transparent);
        }

        .milestone h2 {
            font-size: 24px;
            color: #fff;
            margin-bottom: 20px;
            font-family: 'Chakra Petch', monospace;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .milestone h2::before {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #4f46e5;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.5);
        }

        .milestone-meta {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .date {
            background: rgba(79, 70, 229, 0.1);
            color: #a8b2ff;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 14px;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 14px;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .status.completed {
            background: rgba(16, 185, 129, 0.1);
            color: #34d399;
        }

        .status.in-progress {
            background: rgba(245, 158, 11, 0.1);
            color: #fbbf24;
        }

        .status.planned {
            background: rgba(99, 102, 241, 0.1);
            color: #818cf8;
        }

        .tasks {
            display: grid;
            gap: 20px;
        }

        .task {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            line-height: 1.6;
            padding: 15px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .task:hover {
            background: rgba(255, 255, 255, 0.04);
        }

        .task.completed {
            color: rgba(255, 255, 255, 0.5);
        }

        .task::before {
            content: '';
            width: 24px;
            height: 24px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            flex-shrink: 0;
            margin-top: 2px;
            transition: all 0.3s ease;
        }

        .task.completed::before {
            background: #4f46e5;
            border-color: #4f46e5;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.3);
            content: '✓';
            color: #fff;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-roadmap {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 40px;
            height: 40px;
            border: none;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-roadmap:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(90deg);
        }

        .close-roadmap::before,
        .close-roadmap::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 2px;
            background: rgba(255, 255, 255, 0.8);
            transform: rotate(45deg);
        }

        .close-roadmap::after {
            transform: rotate(-45deg);
        }

        .milestone-progress {
            position: absolute;
            top: 40px;
            right: 40px;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 600;
            color: #4f46e5;
            background: rgba(79, 70, 229, 0.1);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.2);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .milestone {
            animation: fadeIn 0.5s ease forwards;
            animation-delay: calc(var(--index) * 0.1s);
            opacity: 0;
        }

        /* Fix sidebar visibility */
        .nav, .docs-sidebar {
            transition: opacity 0.3s ease;
        }

        .nav.hidden, .docs-sidebar.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .close-modal {
            position: absolute;
            right: 20px;
            top: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 24px;
            transition: color 0.2s ease;
        }

        .close-modal:hover {
            color: rgba(255, 255, 255, 0.9);
        }

        .timeline {
            margin-top: 40px;
            position: relative;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 120px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255, 255, 255, 0.1);
        }

        .timeline-item {
            margin-bottom: 40px;
            position: relative;
            padding-left: 160px;
        }

        .timeline-date {
            position: absolute;
            left: 0;
            top: 0;
            width: 100px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .timeline-content {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .timeline-content h3 {
            margin: 0 0 16px 0;
            color: rgba(255, 255, 255, 0.9);
            font-size: 18px;
            letter-spacing: 0.5px;
        }

        .timeline-content ul {
            margin: 0;
            padding: 0 0 0 20px;
            color: rgba(255, 255, 255, 0.7);
        }

        .timeline-content li {
            margin-bottom: 8px;
            font-size: 14px;
            letter-spacing: 0.5px;
        }

        /* Update the roadmap button styles to match exactly */
        #roadmapButton {
            padding: 8px 16px;
            color: rgba(255, 255, 255, 0.6);
            text-decoration: none;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        #roadmapButton:hover {
            color: rgba(255, 255, 255, 0.9);
            background: rgba(255, 255, 255, 0.05);
        }

        /* Keep all other modal styles the same */
        .roadmap-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(8px);
        }

        /* Remove any cursor-related styles */
        * {
            cursor: default !important;
        }
        
        /* Add this to prevent scrolling on roadmap button click */
        .roadmap-button {
            text-decoration: none;
            pointer-events: auto;
        }

        /* Add these styles inside the existing <style> tag */
        .roadmap-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
            overflow-y: auto;
        }

        .roadmap-content {
            max-width: 800px;
            margin: 50px auto;
            padding: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            font-family: 'Chakra Petch', sans-serif;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .milestone {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 24px;
            margin-bottom: 24px;
            transition: all 0.3s ease;
        }

        .milestone:hover {
            background: rgba(255, 255, 255, 0.05);
            transform: translateY(-2px);
        }

        .milestone-meta {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 20px;
        }

        .date {
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
        }

        .status {
            color: #00ffcc;
            background: rgba(0, 255, 204, 0.1);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            text-transform: uppercase;
            border: 1px solid rgba(0, 255, 204, 0.2);
        }

        .task {
            color: rgba(255, 255, 255, 0.7);
            font-size: 15px;
            padding-left: 24px;
            position: relative;
            margin-bottom: 12px;
        }

        .task.completed {
            color: rgba(255, 255, 255, 0.4);
        }

        .task.completed::before {
            content: '✓';
            position: absolute;
            left: 0;
            color: #00ffcc;
        }

        .close-roadmap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 32px;
            height: 32px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close-roadmap:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(90deg);
        }

        .roadmap-header h1 {
            color: #fff;
            font-size: 28px;
            margin-bottom: 8px;
        }

        .roadmap-header p {
            color: rgba(255, 255, 255, 0.6);
            font-size: 15px;
            margin-bottom: 40px;
        }

        .milestone h2 {
            color: #00ffcc;
            font-size: 18px;
            margin-bottom: 16px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .milestone {
            animation: fadeIn 0.5s ease forwards;
            animation-delay: calc(var(--index) * 0.1s);
            opacity: 0;
        }

        /* Hide scrollbar for Chrome, Safari and Opera */
        ::-webkit-scrollbar {
            display: none;
        }

        /* Hide scrollbar for IE, Edge and Firefox */
        * {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        /* Ensure the body still scrolls */
        body {
            overflow-y: scroll;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        /* Ensure modal content still scrolls */
        .roadmap-modal {
            overflow-y: scroll;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        /* Ensure docs content still scrolls */
        .docs-content {
            overflow-y: scroll;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        .social-links {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1rem;
        }

        .social-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            transition: all 0.2s ease;
            border-radius: 4px;
        }

        .social-link:hover {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
        }

        .social-link i {
            font-size: 1.2rem;
            width: 20px;
            text-align: center;
        }

        /* Update social links to always be interactive */
        .social-links {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1rem;
            pointer-events: auto !important;
            z-index: 100;
            position: relative;
        }

        .social-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            transition: all 0.2s ease;
            border-radius: 4px;
            pointer-events: auto !important;
            cursor: pointer !important;
            z-index: 100;
        }

        .social-link:hover {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
        }

        /* Remove the opacity/pointer-events changes for social links when scrolling */
        .nav.hidden, .docs-sidebar.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .docs-sidebar .social-links,
        .docs-sidebar .social-links * {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* Fresh implementation of social links styles */
        .social-links {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1rem;
            pointer-events: auto !important;
            z-index: 100;
            position: relative;
        }

        .social-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            transition: all 0.2s ease;
            border-radius: 4px;
            pointer-events: auto !important;
            cursor: pointer !important;
            z-index: 100;
        }

        .social-link:hover {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
        }

        .social-link i {
            font-size: 1.2rem;
            width: 20px;
            text-align: center;
        }

        /* Override any other styles that might interfere */
        .docs-sidebar .social-links,
        .docs-sidebar .social-links * {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* Remove any cursor restrictions */
        .social-link {
            cursor: pointer !important;
        }

        /* Ensure links stay visible and interactive */
        .nav.hidden .social-links,
        .docs-sidebar.hidden .social-links {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* Fix sidebar visibility */
        .nav, .docs-sidebar {
            transition: opacity 0.3s ease;
        }

        .nav.hidden, .docs-sidebar.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Ensure main nav links hide properly */
        .main-nav-link {
            transition: opacity 0.3s ease;
        }

        .main-nav-link.hidden {
            opacity: 0;
            pointer-events: none;
            display: none; /* Add this to ensure they don't take up space */
        }

        .diagram-title {
            text-align: center;
            color: rgba(255, 255, 255, 0.95);
            font-size: 24px;
            margin-bottom: 40px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .system-diagram {
            margin: 60px 0;
        }
    </style>
<style>
        .cookie-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #000000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 20px;
            z-index: 1000;
            display: none;
            width: 320px;
            font-family: 'Chakra Petch', sans-serif;
        }

        .cookie-content p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            letter-spacing: 0.5px;
            margin: 0 0 16px 0;
            text-transform: uppercase;
        }

        .cookie-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .cookie-buttons button {
            padding: 8px 20px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            letter-spacing: 1px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Chakra Petch', sans-serif;
        }

        .cookie-buttons button:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .cookie-accept {
                background: rgba(255, 255, 255, 0.05) !important;
            }

            .cookie-accept:hover {
                background: rgba(255, 255, 255, 0.1) !important;
            }
        </style></head>
<body style="cursor: default;">
    <!-- Add quantum field after cursor elements but before main content -->
    
    
    <div class="quantum-field" style="cursor: default;">
        <canvas class="quantum-canvas" id="quantumField" style="cursor: default;"></canvas>
    </div>

    <nav class="nav" style="cursor: default;">
        <a href="#introduction" class="docs-link main-nav-link active" style="cursor: default;">Introduction</a>
        <a href="#installation" class="docs-link main-nav-link" style="cursor: default;">Installation</a>
        <a href="#quick-start" class="docs-link main-nav-link" style="cursor: default;">Quick Start Guide</a>
        <a href="https://x.com/alone_labs" class="docs-link main-nav-link" target="_blank" rel="noopener noreferrer" style="cursor: default;">X - Formerly Twitter</a>
        <a href="https://github.com/intelligentsupply/Divinez" class="docs-link main-nav-link" target="_blank" rel="noopener noreferrer" style="cursor: default;">GitHub Main</a>
        <a href="https://github.com/intelligentsupply/Divinez" class="docs-link main-nav-link" target="_blank" rel="noopener noreferrer" style="cursor: default;">GitHub Versatile AI Engine</a>
    </nav>

    <div class="hero-section" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; background-color: rgb(0, 0, 0); text-align: center; position: relative; cursor: default;">
        <img src="images/alone-removebg-preview.png" alt="Alone Labs" style="width: 60px; margin-bottom: 40px; cursor: default;" class="fade-in">
        
        <h1 class="title-animation" style="font-family: " chakra="" petch",="" sans-serif;="" font-size:="" 64px;="" letter-spacing:="" 8px;="" margin:="" 0px;="" color:="" rgb(255,="" 255,="" 255);="" font-weight:="" 600;="" cursor:="" default;"="">
            DIVINEZ
        </h1>
        
        <div style="margin-top: 20px; cursor: default;">
            <p class="subtitle-animation" style="font-family: " chakra="" petch",="" sans-serif;="" font-size:="" 24px;="" letter-spacing:="" 12px;="" color:="" rgba(255,="" 255,="" 0.6);="" text-transform:="" uppercase;="" margin:="" 0px;="" cursor:="" default;"="">
                BY PYSION PROMT
            </p>
        </div>
        
        <div class="scroll-indicator" style="position: absolute; bottom: 40px; cursor: default;">
            <svg width="20" height="20" viewBox="0 0 20 20" style="fill: rgba(255, 255, 255, 0.6); cursor: default;">
                <path d="M10 15.77l-7.88-7.88L3.53 6.47 10 12.94l6.47-6.47 1.41 1.42z" style="cursor: default;"></path>
            </svg>
        </div>
    </div>

    <div class="docs-container" style="margin-top: -80px; position: relative; z-index: 2; cursor: default;">
        <!-- Sidebar Navigation -->
        <aside class="docs-sidebar" style="cursor: default;">
            <div class="search-container" style="cursor: default;">
                <input type="text" class="search-input" placeholder="Search documentation..." style="cursor: default;">
                <div class="search-results" style="cursor: default;"></div>
            </div>
            
            <!-- Remove social links div completely -->
            
            <nav class="docs-nav" style="cursor: default;">
            <div class="docs-section" style="cursor: default;">
                <h3 class="docs-section-title" style="cursor: default;">Getting Started</h3>
                <a href="#introduction" class="docs-link" style="cursor: default;">Introduction</a>
                <a href="#quick-start" class="docs-link" style="cursor: default;">Quick Start</a>
                <a href="#installation" class="docs-link" style="cursor: default;">Installation</a>
            </div>

            <div class="docs-section" style="cursor: default;">
                <h3 class="docs-section-title" style="cursor: default;">Core Concepts</h3>
                <a href="#architecture" class="docs-link" style="cursor: default;">Architecture</a>
                <a href="#state-management" class="docs-link" style="cursor: default;">State Management</a>
                <a href="#vector-operations" class="docs-link" style="cursor: default;">Vector Operations</a>
            </div>

            <div class="docs-section" style="cursor: default;">
                <h3 class="docs-section-title" style="cursor: default;">Advanced Features</h3>
                <a href="#memory-system" class="docs-link" style="cursor: default;">Memory System</a>
                <a href="#llm-integration" class="docs-link" style="cursor: default;">LLM Integration</a>
                <a href="#plugins" class="docs-link" style="cursor: default;">Plugin System</a>
            </div>
        </nav>
        </aside>

        <!-- Main Content -->
        <main class="docs-content" style="cursor: default;">
                    <header class="docs-header">
                        <h1 class="docs-title">Introduction</h1>
                       
                    </header>
                    
                    <section class="api-section">
                        <h2>Core Architecture</h2>
                        <p>
                            The DIVINEZ is built on a revolutionary multi-layered architecture aimed at maximizing both efficiency and scalability. At its foundation lies a hardware abstraction layer that directly interfaces with custom-designed silicon accelerators. These accelerators house integrated tensor cores that can dynamically switch between SIMD and MIMD processing modes, enabling the system to adapt fluidly to both dense numeric and highly sparse computational workloads.
                        </p>
                        <p>
                            Micro-op fusion techniques are employed to bundle multiple low-level operations into a single kernel execution. This minimizes function call overhead and reduces latency dramatically. In parallel, fine-grained hardware performance metrics—such as cache hit ratios, arithmetic logic unit (ALU) utilization, and branch prediction success—are continuously monitored to feed back into an adaptive scheduler that adjusts execution plans in real time.
                        </p>
                        <p>
                            Each layer of the architecture operates both independently and in concert. The lowest layer manages raw computation and memory allocation, the mid-level handles dynamic scheduling and execution optimization, and the topmost layer abstracts these complexities into developer-friendly APIs. This modular design guarantees that improvements or modifications in one layer have minimal adverse effects on the overall system.
                        </p>
                        
                        <h2>Memory Hierarchy & Cache Optimization</h2>
                        <p>
                            VAE's memory subsystem pioneers a multi-tiered approach that significantly minimizes latency. An aggressively optimized L1 cache uses a hybrid eviction policy that merges traditional LRU methods with frequency-based decisions. This ensures that critical data required for immediate computations remains at the forefront.
                        </p>
                        <p>
                            Beyond the L1 cache, a predictive L2 cache uses embedded machine-learning models to forecast upcoming memory access requests. By prefetching cache lines based on these predictions, the system reduces stalls considerably. In distributed setups, a coherent L3 cache shares data efficiently across multiple nodes, thereby reducing inter-node communication delays.
                        </p>
                        <p>
                            The virtual memory manager supports a broad spectrum of page sizes—from 4KB to 1GB—to optimize memory mapping dynamically based on the nature of the current workload. Zero-copy techniques are also implemented, which allow for seamless, direct data transfers between CPU and GPU memories without the latency of intermediate copying.
                        </p>
                        
                        <h2>Execution Pipeline & Graph Optimization</h2>
                        <p>
                            The execution engine of VAE is designed to be both dynamic and self-correcting. It decomposes tasks into several stages: instruction decoding, kernel scheduling, and runtime graph optimization. Initial static analysis uses Directed Acyclic Graph (DAG) modeling to capture inter-operation dependencies, thereby enabling loop unrolling, tiling, and operation reordering during the compile phase.
                        </p>
                        <p>
                            At runtime, dynamic kernel fusion merges compatible operations into a single, streamlined kernel invocation—minimizing dispatch overhead. The scheduler leverages an advanced cost model that factors in current memory latency, cache availability, and compute unit contention to reorder tasks effectively in real time. This careful orchestration ensures maximum parallelism, both at the task level and within each data batch.
                        </p>
                        <p>
                            Speculative executions prepare alternate computational pathways for non-critical operations. These are quickly validated using integrated integrity checks, ensuring that even if the speculation fails, the system rapidly falls back to a correct execution path with negligible overall delay.
                        </p>
                        
                        <h2>Advanced Numerical Precision & Stability</h2>
                        <p>
                            VAE stands out with its dynamic control over numerical precision. Instead of a one-size-fits-all approach, the framework supports multiple formats including FP16, BF16, FP32, FP64, and proprietary fixed-point arithmetic. Static analysis techniques such as interval arithmetic are employed alongside live error monitoring to decide the optimum precision for each operation.
                        </p>
                        <p>
                            When error accumulations are detected, the system automatically promotes calculations to a higher-precision format or reroutes them through redundant computations with weighted error checks. This dynamic precision scaling ensures that results remain stable even through deep, multi-layered computations, which is critical for both training and inference in complex neural networks.
                        </p>
                        <p>
                            Iterative refinement loops are used in particularly sensitive operations. By recalculating outputs and comparing them against error thresholds, the system continuously maintains an error-bounded solution, effectively balancing computational speed with numerical accuracy.
                        </p>
                        
                        <h2>Synchronization & Inter-Component Communication</h2>
                        <p>
                            In a highly parallel system, robust synchronization is essential. VAE employs state-of-the-art synchronization primitives including hardware-assisted lock-free data structures, fine-grained spin locks, and atomic operations that are tailored for tensor computations. These mechanisms reduce contention and ensure coherent state transitions across thousands of processing threads.
                        </p>
                        <p>
                            A bespoke communication protocol facilitates rapid data sharing between system components. This protocol features dynamic flow control algorithms that adjust in real time to network congestion and shifting load patterns, ensuring that inter-component messaging remains both low-latency and reliable. 
                        </p>
                        <p>
                            Redundant error correction and fault-tolerant pathways are also in place. Should synchronization conflicts arise, the framework can quickly roll back partial operations and redistribute work to maintain overall system integrity.
                        </p>
                        
                        <h2>Data Processing & Preprocessing Pipeline</h2>
                        <p>
                            The data processing pipeline in VAE is engineered for massive scalability and resilience. Incoming data streams are separated by type and routed to dedicated preprocessing units that perform normalization, augmentation, and complex feature extractions concurrently. This ensures that raw data is transformed into a readily usable form as quickly as possible.
                        </p>
                        <p>
                            Intelligent batching algorithms dynamically group data into optimal sizes based on real-time analysis of throughput requirements and processing complexity. This adaptive grouping maximizes computational efficiency while minimizing idle time. Data is then managed by a hierarchical caching system that prioritizes fast access for the most critical information.
                        </p>
                        <p>
                            An integrated anomaly detection system continuously scans for data irregularities. Using statistical techniques and pattern recognition, the system flags and isolates any anomalies, ensuring that only clean, high-fidelity data propagates through the neural network layers.
                        </p>
                        
                        <h2>Development, Deployment & Monitoring Tools</h2>
                        <p>
                            VAE provides an exhaustive suite of development tools designed for deep system introspection and seamless deployment. Integrated debuggers allow developers to step through intricate computational graphs and inspect variable states at all levels of abstraction. Real-time profilers gather granular metrics from GPU cores to system-wide memory throughput, providing valuable insights into operational bottlenecks.
                        </p>
                        <p>
                            Deployment pipelines are automated via rigorous CI/CD frameworks that enforce both unit and stress testing. Every code update is benchmarked across multiple simulated environments, and automated rollback mechanisms are in place to quickly revert problematic updates. This guarantees that only thoroughly validated changes reach production.
                        </p>
                        <p>
                            Additionally, real-time monitoring dashboards present key performance indicators—such as GPU utilization, memory bandwidth usage, network latency, and error rates—in an intuitive, highly granular format. Detailed logging and alerting systems ensure that any deviations in performance or unexpected anomalies are rapidly communicated to system administrators, enabling proactive maintenance and rapid problem resolution.
                        </p>
                    </section>
                </main>

        <!-- Table of Contents -->
        <aside class="toc" style="cursor: default;">
            <h3 class="toc-title" style="cursor: default;">On This Page</h3>
            <a href="#introduction" class="toc-link" style="cursor: default;">Introduction</a>
            <a href="#quick-start" class="toc-link" style="cursor: default;">Quick Start</a>
            <a href="#installation" class="toc-link" style="cursor: default;">API Reference</a>
        </aside>
    </div>

    <script style="cursor: default;">
        // Custom cursor
        const cursor = document.querySelector('.cursor');
        const cursorFollower = document.querySelector('.cursor-follower');
        
        document.addEventListener('mousemove', (e) => {
            cursor.style.transform = `translate3d(${e.clientX - 10}px, ${e.clientY - 10}px, 0)`;
            cursorFollower.style.transform = `translate3d(${e.clientX - 4}px, ${e.clientY - 4}px, 0)`;
        });

        // Add scroll listener
        window.addEventListener('scroll', () => {
            const docsSection = document.querySelector('.docs-container');
            const mainNavLinks = document.querySelectorAll('.main-nav-link');
            
            if (docsSection) {
                const docsSectionTop = docsSection.getBoundingClientRect().top;
                
                if (docsSectionTop <= 0) {
                    mainNavLinks.forEach(link => link.classList.add('hidden'));
                } else {
                    mainNavLinks.forEach(link => link.classList.remove('hidden'));
                }
            }
        });

        // Add click handler for ALL docs links
        document.addEventListener('click', (e) => {
            const link = e.target.closest('.docs-link');
            if (!link) return; // Exit if click wasn't on or within a docs-link
            
            // Check if the link is external (has http/https)
            const href = link.getAttribute('href');
            if (href.startsWith('http')) {
                window.open(href, '_blank', 'noopener,noreferrer');
                e.preventDefault(); // Prevent default to handle it our way
                return;
            }
            
            e.preventDefault();
            const docsSection = document.querySelector('.docs-container');
            docsSection.scrollIntoView({ behavior: 'smooth' });
            
            // After scrolling to docs section, scroll to specific section
            setTimeout(() => {
                const targetSection = document.querySelector(href);
                if (targetSection) {
                    targetSection.scrollIntoView({ behavior: 'smooth' });
                }
            }, 500);
        });

        // Update sidebar navigation structure first
        document.querySelector('.docs-nav').innerHTML = `
            <div class="docs-section">
                <h3 class="docs-section-title">Getting Started</h3>
                <a href="#introduction" class="docs-link">Introduction</a>
                <a href="#quick-start" class="docs-link">Quick Start</a>
                <a href="#installation" class="docs-link">Installation</a>
            </div>

            <div class="docs-section">
                <h3 class="docs-section-title">Core Concepts</h3>
                <a href="#architecture" class="docs-link">Architecture</a>
                <a href="#state-management" class="docs-link">State Management</a>
                <a href="#vector-operations" class="docs-link">Vector Operations</a>
            </div>

            <div class="docs-section">
                <h3 class="docs-section-title">Advanced Features</h3>
                <a href="#memory-system" class="docs-link">Memory System</a>
                <a href="#llm-integration" class="docs-link">LLM Integration</a>
                <a href="#plugins" class="docs-link">Plugin System</a>
            </div>
        `;

        // Update documentation content with more detail
        const docsContent = {
            'introduction': {
                title: 'Introduction',
                content: `
                    <header class="docs-header">
                        <h1 class="docs-title">Introduction</h1>
                       
                    </header>
                    
                    <section class="api-section">
                        <h2>Core Architecture</h2>
                        <p>
                            The VAE framework is built on a revolutionary multi-layered architecture aimed at maximizing both efficiency and scalability. At its foundation lies a hardware abstraction layer that directly interfaces with custom-designed silicon accelerators. These accelerators house integrated tensor cores that can dynamically switch between SIMD and MIMD processing modes, enabling the system to adapt fluidly to both dense numeric and highly sparse computational workloads.
                        </p>
                        <p>
                            Micro-op fusion techniques are employed to bundle multiple low-level operations into a single kernel execution. This minimizes function call overhead and reduces latency dramatically. In parallel, fine-grained hardware performance metrics—such as cache hit ratios, arithmetic logic unit (ALU) utilization, and branch prediction success—are continuously monitored to feed back into an adaptive scheduler that adjusts execution plans in real time.
                        </p>
                        <p>
                            Each layer of the architecture operates both independently and in concert. The lowest layer manages raw computation and memory allocation, the mid-level handles dynamic scheduling and execution optimization, and the topmost layer abstracts these complexities into developer-friendly APIs. This modular design guarantees that improvements or modifications in one layer have minimal adverse effects on the overall system.
                        </p>
                        
                        <h2>Memory Hierarchy & Cache Optimization</h2>
                        <p>
                            VAE's memory subsystem pioneers a multi-tiered approach that significantly minimizes latency. An aggressively optimized L1 cache uses a hybrid eviction policy that merges traditional LRU methods with frequency-based decisions. This ensures that critical data required for immediate computations remains at the forefront.
                        </p>
                        <p>
                            Beyond the L1 cache, a predictive L2 cache uses embedded machine-learning models to forecast upcoming memory access requests. By prefetching cache lines based on these predictions, the system reduces stalls considerably. In distributed setups, a coherent L3 cache shares data efficiently across multiple nodes, thereby reducing inter-node communication delays.
                        </p>
                        <p>
                            The virtual memory manager supports a broad spectrum of page sizes—from 4KB to 1GB—to optimize memory mapping dynamically based on the nature of the current workload. Zero-copy techniques are also implemented, which allow for seamless, direct data transfers between CPU and GPU memories without the latency of intermediate copying.
                        </p>
                        
                        <h2>Execution Pipeline & Graph Optimization</h2>
                        <p>
                            The execution engine of VAE is designed to be both dynamic and self-correcting. It decomposes tasks into several stages: instruction decoding, kernel scheduling, and runtime graph optimization. Initial static analysis uses Directed Acyclic Graph (DAG) modeling to capture inter-operation dependencies, thereby enabling loop unrolling, tiling, and operation reordering during the compile phase.
                        </p>
                        <p>
                            At runtime, dynamic kernel fusion merges compatible operations into a single, streamlined kernel invocation—minimizing dispatch overhead. The scheduler leverages an advanced cost model that factors in current memory latency, cache availability, and compute unit contention to reorder tasks effectively in real time. This careful orchestration ensures maximum parallelism, both at the task level and within each data batch.
                        </p>
                        <p>
                            Speculative executions prepare alternate computational pathways for non-critical operations. These are quickly validated using integrated integrity checks, ensuring that even if the speculation fails, the system rapidly falls back to a correct execution path with negligible overall delay.
                        </p>
                        
                        <h2>Advanced Numerical Precision & Stability</h2>
                        <p>
                            VAE stands out with its dynamic control over numerical precision. Instead of a one-size-fits-all approach, the framework supports multiple formats including FP16, BF16, FP32, FP64, and proprietary fixed-point arithmetic. Static analysis techniques such as interval arithmetic are employed alongside live error monitoring to decide the optimum precision for each operation.
                        </p>
                        <p>
                            When error accumulations are detected, the system automatically promotes calculations to a higher-precision format or reroutes them through redundant computations with weighted error checks. This dynamic precision scaling ensures that results remain stable even through deep, multi-layered computations, which is critical for both training and inference in complex neural networks.
                        </p>
                        <p>
                            Iterative refinement loops are used in particularly sensitive operations. By recalculating outputs and comparing them against error thresholds, the system continuously maintains an error-bounded solution, effectively balancing computational speed with numerical accuracy.
                        </p>
                        
                        <h2>Synchronization & Inter-Component Communication</h2>
                        <p>
                            In a highly parallel system, robust synchronization is essential. VAE employs state-of-the-art synchronization primitives including hardware-assisted lock-free data structures, fine-grained spin locks, and atomic operations that are tailored for tensor computations. These mechanisms reduce contention and ensure coherent state transitions across thousands of processing threads.
                        </p>
                        <p>
                            A bespoke communication protocol facilitates rapid data sharing between system components. This protocol features dynamic flow control algorithms that adjust in real time to network congestion and shifting load patterns, ensuring that inter-component messaging remains both low-latency and reliable. 
                        </p>
                        <p>
                            Redundant error correction and fault-tolerant pathways are also in place. Should synchronization conflicts arise, the framework can quickly roll back partial operations and redistribute work to maintain overall system integrity.
                        </p>
                        
                        <h2>Data Processing & Preprocessing Pipeline</h2>
                        <p>
                            The data processing pipeline in VAE is engineered for massive scalability and resilience. Incoming data streams are separated by type and routed to dedicated preprocessing units that perform normalization, augmentation, and complex feature extractions concurrently. This ensures that raw data is transformed into a readily usable form as quickly as possible.
                        </p>
                        <p>
                            Intelligent batching algorithms dynamically group data into optimal sizes based on real-time analysis of throughput requirements and processing complexity. This adaptive grouping maximizes computational efficiency while minimizing idle time. Data is then managed by a hierarchical caching system that prioritizes fast access for the most critical information.
                        </p>
                        <p>
                            An integrated anomaly detection system continuously scans for data irregularities. Using statistical techniques and pattern recognition, the system flags and isolates any anomalies, ensuring that only clean, high-fidelity data propagates through the neural network layers.
                        </p>
                        
                        <h2>Development, Deployment & Monitoring Tools</h2>
                        <p>
                            VAE provides an exhaustive suite of development tools designed for deep system introspection and seamless deployment. Integrated debuggers allow developers to step through intricate computational graphs and inspect variable states at all levels of abstraction. Real-time profilers gather granular metrics from GPU cores to system-wide memory throughput, providing valuable insights into operational bottlenecks.
                        </p>
                        <p>
                            Deployment pipelines are automated via rigorous CI/CD frameworks that enforce both unit and stress testing. Every code update is benchmarked across multiple simulated environments, and automated rollback mechanisms are in place to quickly revert problematic updates. This guarantees that only thoroughly validated changes reach production.
                        </p>
                        <p>
                            Additionally, real-time monitoring dashboards present key performance indicators—such as GPU utilization, memory bandwidth usage, network latency, and error rates—in an intuitive, highly granular format. Detailed logging and alerting systems ensure that any deviations in performance or unexpected anomalies are rapidly communicated to system administrators, enabling proactive maintenance and rapid problem resolution.
                        </p>
                    </section>
                `
            },
            'quick-start': {
                title: 'Quick Start Guide',
                content: `
                    <header class="docs-header">
                        <h1 class="docs-title">Quick Start Guide</h1>
                        <p class="docs-description">Embark on your journey with VAE's revolutionary AI framework</p>
                    </header>
                    
                    <section class="api-section">
                        <h2>Introduction to VAE</h2>
                        <p>
                            VAE represents a fundamental shift in artificial intelligence frameworks, introducing unprecedented capabilities in neural processing and system architecture. As you begin your journey with VAE, you'll discover a framework that transcends traditional boundaries, offering unparalleled performance and sophistication in AI development.
                        </p>
                        <p>
                            At its core, VAE employs advanced neural architectures that dynamically adapt to computational demands, automatically optimizing resource allocation and processing pathways. This sophisticated system leverages cutting-edge algorithms for workload distribution and resource optimization, ensuring optimal performance across diverse deployment scenarios.
                        </p>

                        <h2>Architectural Foundations</h2>
                        <p>
                            VAE's architecture represents a quantum leap in AI system design, incorporating advanced neural processing capabilities with sophisticated distributed computing paradigms. The framework's core components work in concert to deliver unprecedented performance and scalability, while maintaining the flexibility required for diverse application scenarios.
                        </p>
                        <p>
                            Through its innovative approach to neural network optimization, VAE automatically adapts to varying computational loads, dynamically adjusting resource allocation and processing strategies. This adaptive architecture ensures optimal performance across a wide spectrum of deployment scenarios, from development environments to large-scale production systems.
                        </p>

                        <div class="system-diagram">
                            
                            <svg width="100%" height="400" viewBox="0 0 1000 300" preserveAspectRatio="xMidYMid meet">
                                <!-- Development Environment -->
                                <g transform="translate(100,50)">
                                    <rect width="200" height="200" rx="6" fill="rgba(0,0,0,0.4)" stroke="rgba(255,255,255,0.12)" stroke-width="1"/>
                                    <text x="100" y="40" fill="rgba(255,255,255,0.95)" font-size="16" text-anchor="middle">Neural Core</text>
                                    <line x1="20" y1="60" x2="180" y2="60" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                                    <text x="100" y="90" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Vector Processing</text>
                                    <text x="100" y="120" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">State Management</text>
                                    <text x="100" y="150" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Memory Systems</text>
                                </g>

                                <!-- VAE Core -->
                                <g transform="translate(400,50)">
                                    <rect width="200" height="200" rx="6" fill="rgba(0,0,0,0.4)" stroke="rgba(255,255,255,0.12)" stroke-width="1"/>
                                    <text x="100" y="40" fill="rgba(255,255,255,0.95)" font-size="16" text-anchor="middle">Runtime Engine</text>
                                    <line x1="20" y1="60" x2="180" y2="60" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                                    <text x="100" y="90" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Optimization</text>
                                    <text x="100" y="120" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Distribution</text>
                                    <text x="100" y="150" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Scheduling</text>
                                </g>

                                <!-- Application -->
                                <g transform="translate(700,50)">
                                    <rect width="200" height="200" rx="6" fill="rgba(0,0,0,0.4)" stroke="rgba(255,255,255,0.12)" stroke-width="1"/>
                                    <text x="100" y="40" fill="rgba(255,255,255,0.95)" font-size="16" text-anchor="middle">Integration Layer</text>
                                    <line x1="20" y1="60" x2="180" y2="60" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                                    <text x="100" y="90" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">API Systems</text>
                                    <text x="100" y="120" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Data Flow</text>
                                    <text x="100" y="150" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Security</text>
                                </g>

                                <!-- Connecting Lines -->
                                <g stroke="rgba(255,255,255,0.2)" stroke-width="1">
                                    <path d="M 300 150 L 400 150"/>
                                    <path d="M 600 150 L 700 150"/>
                                </g>
                            </svg>
                        </div>

                        <h2>Neural Processing Configuration</h2>
                        <p>
                            VAE's neural processing engine represents a breakthrough in AI computation, employing sophisticated algorithms for workload distribution and resource optimization. The framework's initialization process automatically configures optimal parameters for neural network operations, establishing a foundation for advanced AI processing capabilities.
                        </p>
                        <p>
                            The system's advanced memory management protocols ensure efficient utilization of computational resources, while its sophisticated caching mechanisms optimize data access patterns for maximum throughput. These capabilities are complemented by an intelligent scheduling system that maintains optimal performance under varying load conditions.
                        </p>

                        <h2>Vector Processing Systems</h2>
                        <p>
                            At the heart of VAE lies a sophisticated vector processing system that leverages advanced mathematical models for optimal computation. This system employs cutting-edge tensor operations and parallel processing techniques to maximize throughput and minimize latency across all operations.
                        </p>
                        <p>
                            The vector processing engine incorporates advanced optimization algorithms that automatically adjust computational pathways based on real-time performance metrics. This dynamic optimization ensures optimal resource utilization while maintaining strict performance standards across all operations.
                        </p>

                        <div class="feature-grid">
                            <div class="feature-item">
                                <h3>Tensor Operations</h3>
                                <ul>
                                    <li><strong>Dynamic Allocation:</strong> Real-time tensor memory management</li>
                                    <li><strong>Parallel Processing:</strong> Advanced multi-dimensional computations</li>
                                    <li><strong>Optimization Paths:</strong> Automated computational route selection</li>
                        </ul>
                            </div>
                            <div class="feature-item">
                                <h3>Memory Systems</h3>
                                <ul>
                                    <li><strong>Cache Hierarchy:</strong> Multi-level caching architecture</li>
                                    <li><strong>Predictive Loading:</strong> Advanced data prefetching mechanisms</li>
                                    <li><strong>Memory Coherence:</strong> Distributed state synchronization</li>
                                </ul>
                            </div>
                        </div>

                        <h2>Runtime Environment</h2>
                        <p>
                            VAE's runtime environment represents a sophisticated orchestration of multiple subsystems working in harmony. The environment incorporates advanced scheduling algorithms, dynamic resource allocation, and intelligent load balancing mechanisms to ensure optimal performance across all operations.
                        </p>
                        
                        <p>
                            The runtime system employs sophisticated monitoring and adaptation mechanisms that continuously optimize performance based on real-time metrics. This includes advanced memory management, intelligent thread scheduling, and dynamic load balancing across available computational resources.
                        </p>

                        <div class="code-example">
                            <pre><code class="language-bash">
# Initialize advanced runtime configurations
export VAE_RUNTIME_MODE=advanced
export VAE_THREAD_MODEL=adaptive
export VAE_MEMORY_POLICY=dynamic

# Configure optimization parameters
export VAE_TENSOR_OPTIMIZATION=enabled
export VAE_CACHE_STRATEGY=predictive
export VAE_PREFETCH_DEPTH=adaptive
                            </code></pre>
</div>

                        <h2>State Management Systems</h2>
                        <p>
                            VAE implements a sophisticated state management system that maintains consistency across distributed environments. This system employs advanced synchronization protocols and distributed consensus algorithms to ensure data coherence and system stability.
                        </p>

                        <p>
                            The state management layer incorporates advanced conflict resolution mechanisms and automatic recovery procedures, ensuring system reliability even under adverse conditions. This is complemented by a sophisticated logging and monitoring system that provides detailed insights into system behavior and performance characteristics.
                        </p>

                        <div class="code-example">
                            <pre><code class="language-bash">
# Initialize state management
state_manager = StateManager(
    consistency_model="eventual",
    sync_protocol="raft",
    partition_tolerance="automatic"
)

# Configure state synchronization
state_manager.configure_sync(
    replication_factor=3,
    sync_interval="10ms",
    conflict_resolution="vector_clock"
)
                            </code></pre>
                        </div>

                        <h2>Resource Optimization</h2>
                        <p>
                            VAE's resource optimization system represents a sophisticated approach to system tuning and resource management. The framework employs advanced heuristics and machine learning algorithms to continuously optimize system behavior based on real-time performance metrics.
                        </p>

                        <p>
                            The optimization engine incorporates sophisticated profiling tools and advanced analytics capabilities that provide detailed insights into system performance. This information is used to automatically adjust system parameters and optimize resource allocation for maximum efficiency.
                        </p>

                        <div class="feature-grid">
                            <div class="feature-item">
                                <h3>Compute Optimization</h3>
                                <ul>
                                    <li><strong>Workload Analysis:</strong> Real-time performance profiling</li>
                                    <li><strong>Resource Allocation:</strong> Dynamic compute distribution</li>
                                    <li><strong>Pipeline Tuning:</strong> Automatic pipeline optimization</li>
                                    <li><strong>Cache Management:</strong> Intelligent cache strategies</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h3>Memory Optimization</h3>
                                <ul>
                                    <li><strong>Memory Patterns:</strong> Access pattern analysis</li>
                                    <li><strong>Allocation Strategies:</strong> Smart memory management</li>
                                    <li><strong>Garbage Collection:</strong> Optimized memory recovery</li>
                                    <li><strong>Prefetching:</strong> Predictive data loading</li>
                                </ul>
                            </div>
                            </div>

                        <h2>Advanced Features</h2>
                        <p>
                            VAE incorporates several advanced features that enhance its processing capabilities and system performance. These features leverage cutting-edge research in distributed systems and neural network optimization to deliver unprecedented levels of efficiency and scalability.
                        </p>

                        <p>
                            The framework's advanced features include sophisticated pipeline optimization techniques, dynamic workload partitioning, and intelligent resource allocation strategies. These capabilities are automatically tuned based on system performance metrics and workload characteristics.
                        </p>

                        <div class="code-example">
                            <pre><code class="language-bash">
# Initialize advanced features
advanced = AdvancedFeatures(
    pipeline_optimization="dynamic",
    workload_partitioning="adaptive",
    resource_allocation="intelligent"
)

# Configure optimization strategies
advanced.configure_pipeline(
    stages=["preprocess", "compute", "aggregate"],
    optimization_strategy="throughput",
    latency_target="microseconds"
)
                            </code></pre>
</div>

                        <h2>Performance Monitoring</h2>
                        <p>
                            VAE's performance monitoring system provides comprehensive insights into system behavior and resource utilization. The monitoring infrastructure collects detailed metrics across all system components and provides real-time analysis of system performance.
                        </p>

                        <p>
                            The monitoring system implements sophisticated data collection and analysis mechanisms that enable real-time performance optimization. This includes detailed profiling of compute resources, memory usage, network performance, and overall system efficiency.
                        </p>

                        <div class="feature-grid">
                            <div class="feature-item">
                                <h3>System Metrics</h3>
                                <ul>
                                    <li><strong>Compute Usage:</strong> CPU and GPU utilization</li>
                                    <li><strong>Memory Stats:</strong> Allocation and efficiency</li>
                                    <li><strong>Network Performance:</strong> Throughput and latency</li>
                                    <li><strong>Resource Efficiency:</strong> Utilization analysis</li>
                                </ul>
                                    </div>
                            <div class="feature-item">
                                <h3>Performance Analysis</h3>
                                <ul>
                                    <li><strong>Real-time Analysis:</strong> Continuous monitoring</li>
                                    <li><strong>Trend Analysis:</strong> Performance patterns</li>
                                    <li><strong>Bottleneck Detection:</strong> Performance issues</li>
                                    <li><strong>Optimization Suggestions:</strong> Improvement recommendations</li>
                                </ul>
                            </div>
                        </div>
                    </section>
                `
            },
            'installation': {
                title: 'Installation',
                content: `
                <header class="docs-header">
                        <h1 class="docs-title">Installation</h1>
                        <p class="docs-description">Advanced deployment and configuration of the VAE framework</p>
                    </header>
                    
                    <section class="api-section">
                        <h2>Installation Architecture</h2>
                        <p>
                            VAE's installation process represents a sophisticated approach to system deployment, incorporating advanced containerization techniques and intelligent configuration management. The framework's installation architecture ensures consistent behavior across diverse computing environments while maintaining optimal performance characteristics.
                        </p>
                        <p>
                            Through its innovative deployment mechanisms, VAE automatically adapts to the host environment, optimizing resource allocation and system configurations based on available hardware capabilities. This adaptive installation process ensures optimal performance from initial deployment through production scaling.
                        </p>

                        <div class="system-diagram">
                            
                            <svg width="100%" height="400" viewBox="0 0 1000 300" preserveAspectRatio="xMidYMid meet">
                                <!-- Core Components -->
                                <g transform="translate(100,50)">
                                    <rect width="200" height="200" rx="6" fill="rgba(0,0,0,0.4)" stroke="rgba(255,255,255,0.12)" stroke-width="1"/>
                                    <text x="100" y="40" fill="rgba(255,255,255,0.95)" font-size="16" text-anchor="middle">Core Components</text>
                                    <line x1="20" y1="60" x2="180" y2="60" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                                    <text x="100" y="90" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Neural Engine</text>
                                    <text x="100" y="120" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Memory Systems</text>
                                    <text x="100" y="150" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">State Manager</text>
                                </g>

                                <!-- Deployment Layer -->
                                <g transform="translate(400,50)">
                                    <rect width="200" height="200" rx="6" fill="rgba(0,0,0,0.4)" stroke="rgba(255,255,255,0.12)" stroke-width="1"/>
                                    <text x="100" y="40" fill="rgba(255,255,255,0.95)" font-size="16" text-anchor="middle">Deployment Layer</text>
                                    <line x1="20" y1="60" x2="180" y2="60" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                                    <text x="100" y="90" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Container Orchestration</text>
                                    <text x="100" y="120" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Resource Management</text>
                                    <text x="100" y="150" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Security Protocols</text>
                                </g>

                                <!-- Runtime Environment -->
                                <g transform="translate(700,50)">
                                    <rect width="200" height="200" rx="6" fill="rgba(0,0,0,0.4)" stroke="rgba(255,255,255,0.12)" stroke-width="1"/>
                                    <text x="100" y="40" fill="rgba(255,255,255,0.95)" font-size="16" text-anchor="middle">Runtime Environment</text>
                                    <line x1="20" y1="60" x2="180" y2="60" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                                    <text x="100" y="90" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Process Management</text>
                                    <text x="100" y="120" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Network Integration</text>
                                    <text x="100" y="150" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Monitoring Systems</text>
                                </g>

                                <!-- Connecting Lines -->
                                <g stroke="rgba(255,255,255,0.2)" stroke-width="1">
                                    <path d="M 300 150 L 400 150"/>
                                    <path d="M 600 150 L 700 150"/>
                                </g>
                            </svg>
                        </div>

                        <h2>System Requirements</h2>
                        <p>
                            VAE's sophisticated architecture demands a carefully optimized computing environment to ensure optimal performance. The framework's resource management system automatically adapts to available hardware capabilities, implementing advanced optimization strategies based on system specifications.
                        </p>

                        <div class="feature-grid">
                            <div class="feature-item">
                                <h3>Compute Resources</h3>
                                <ul>
                                    <li><strong>Processor Architecture:</strong> Advanced x86-64 or ARM64 with vector processing capabilities</li>
                                    <li><strong>Memory Systems:</strong> Minimum 16GB RAM with ECC support recommended</li>
                                    <li><strong>Storage Architecture:</strong> NVMe SSD with high IOPS capabilities</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h3>Network Infrastructure</h3>
                                <ul>
                                    <li><strong>Bandwidth:</strong> 10Gbps+ network interfaces for optimal data transfer</li>
                                    <li><strong>Latency:</strong> Sub-millisecond network response times</li>
                                    <li><strong>Protocol Support:</strong> Advanced TCP optimization capabilities</li>
                                </ul>
                            </div>
                        </div>

                        <h2>Container Deployment</h2>
                        <p>
                            VAE leverages sophisticated containerization techniques to ensure consistent deployment across diverse environments. The framework's container architecture implements advanced isolation mechanisms and resource management protocols, ensuring optimal performance and security.
                        </p>
                        <p>
                            The containerization system employs advanced orchestration capabilities, automatically managing resource allocation and system configurations. This sophisticated approach ensures reliable deployment while maintaining strict performance and security standards.
                        </p>

                        <div class="code-example">
                            <pre><code class="language-bash">
# Initialize advanced container deployment
docker pull vae/neural-engine:latest

# Configure container optimization parameters
docker run -d \
    --name vae-instance \
    --gpus all \
    --shm-size=8g \
    --ulimit memlock=-1 \
    --ulimit stack=67108864 \
    vae/neural-engine:latest
                            </code></pre>
                        </div>

                        <h2>Environment Configuration</h2>
                        <p>
                            VAE's configuration system represents a sophisticated approach to environment management, implementing advanced parameter tuning and optimization strategies. The framework automatically adapts to deployment environments, optimizing performance based on available resources.
                        </p>

                        <div class="code-example">
                            <pre><code class="language-bash">
# Configure advanced runtime parameters
export VAE_RUNTIME_MODE=performance
export VAE_MEMORY_POLICY=adaptive
export VAE_NETWORK_OPTIMIZATION=enabled

# Initialize system optimizations
export VAE_TENSOR_COMPUTE=advanced
export VAE_CACHE_STRATEGY=intelligent
export VAE_THREAD_MODEL=dynamic
                            </code></pre>
                    </div>

                        <h2>Security Implementation</h2>
                        <p>
                            Security in VAE's installation process is implemented through a sophisticated multi-layered architecture. The framework employs advanced encryption protocols, secure communication channels, and robust authentication mechanisms throughout the deployment process.
                        </p>
                        <p>
                            The security system includes advanced integrity verification, automatic vulnerability assessment, and comprehensive audit logging capabilities. These features ensure secure deployment while maintaining system performance and reliability.
                        </p>

                        <div class="feature-grid">
                            <div class="feature-item">
                                <h3>Security Protocols</h3>
                                <ul>
                                    <li><strong>Encryption:</strong> Advanced AES-256 with hardware acceleration</li>
                                    <li><strong>Authentication:</strong> Multi-factor security with biometric support</li>
                                    <li><strong>Access Control:</strong> Role-based security with granular permissions</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h3>Monitoring Systems</h3>
                                <ul>
                                    <li><strong>Intrusion Detection:</strong> Real-time threat monitoring</li>
                                    <li><strong>Audit Logging:</strong> Comprehensive security event tracking</li>
                                    <li><strong>Compliance:</strong> Automated regulatory adherence</li>
                                </ul>
                            </div>
                        </div>

                        <h2>Performance Optimization</h2>
                        <p>
                            VAE's installation process incorporates sophisticated performance optimization techniques that ensure optimal system behavior from initial deployment. The framework employs advanced heuristics and machine learning algorithms to continuously optimize system parameters based on deployment characteristics.
                        </p>
                        <p>
                            The optimization engine includes advanced profiling tools and analytics capabilities that provide detailed insights into system performance during installation. This information drives automatic parameter adjustment and resource allocation optimization.
                        </p>

                        <div class="code-example">
                            <pre><code class="language-bash">
# Initialize performance optimization
vae optimize --mode=deployment --scope=system

# Configure advanced monitoring
vae monitor --metrics=comprehensive --interval=100ms

# Enable advanced profiling
vae profile --level=detailed --output=structured
                            </code></pre>
                        </div>

                        <h2>Distributed Deployment</h2>
                        <p>
                            VAE supports sophisticated distributed deployment scenarios through its advanced orchestration capabilities. The framework implements intelligent load distribution, automatic failover, and sophisticated state synchronization across distributed instances.
                        </p>
                        <p>
                            The distributed deployment system employs advanced consensus algorithms and state management protocols to ensure system consistency and reliability. This sophisticated approach enables seamless scaling while maintaining optimal performance across the distributed environment.
                        </p>
                    </section>
                `
            },
            'architecture': {
                title: 'Architecture',
                content: `
                    <header class="docs-header">
                        <h1 class="docs-title">Architecture</h1>
                        <p class="docs-description">Core architectural principles and system design</p>
                </header>
                
                <section class="api-section">
                    <h2>Core Architecture</h2>
                    <p>
                            Modern neural networks demand increasingly sophisticated architectures to handle complex computational challenges. Through innovative design principles and advanced engineering, this framework introduces a revolutionary multi-layered approach to neural processing and distributed computing. The system integrates cutting-edge tensor computation with distributed processing capabilities, setting new standards for performance and scalability.
                        </p>

                        <p>
                            Sophisticated separation of concerns drives the three-tier architectural design, carefully balancing neural processing, resource management, and distribution layers. Each tier operates with remarkable independence while maintaining seamless integration through advanced protocols. The neural core executes AI-specific computations with unprecedented efficiency, while the processing layer orchestrates resource allocation and optimization.
                        </p>

                        <p>
                            Advanced hardware acceleration capabilities form the foundation of the processing infrastructure. Through dynamic optimization strategies and sophisticated resource management, the system adapts in real-time to varying workload characteristics. This adaptive capability ensures optimal performance across diverse computing environments, from development clusters to large-scale production deployments.
                        </p>

                        <div class="feature-grid">
                            <div class="feature-item">
                                <h3>Core Components</h3>
                                <ul>
                                    <li><strong>Neural Engine:</strong> Advanced processing core</li>
                                    <li><strong>Resource Manager:</strong> Dynamic allocation system</li>
                                    <li><strong>Distribution Layer:</strong> Scalable architecture</li>
                                    <li><strong>Memory Systems:</strong> Multi-tier hierarchy</li>
                        </ul>
                            </div>
                            <div class="feature-item">
                                <h3>Key Features</h3>
                                <ul>
                                    <li><strong>Adaptive Processing:</strong> Real-time optimization</li>
                                    <li><strong>Parallel Execution:</strong> Distributed computing</li>
                                    <li><strong>Dynamic Scaling:</strong> Automatic resource scaling</li>
                                    <li><strong>Hardware Acceleration:</strong> Optimized computation</li>
                                </ul>
                            </div>
                        </div>

                        <h2>Memory Architecture</h2>
                        <p>
                            Traditional memory management approaches often struggle with the demands of modern neural networks. Breaking from convention, this framework introduces a revolutionary multi-tier memory hierarchy that fundamentally transforms data access patterns. Sophisticated support for heterogeneous memory architectures enables optimal utilization across different memory types, adapting dynamically to access patterns and performance requirements.
                        </p>

                        <p>
                            Predictive loading strategies and intelligent caching mechanisms form the core of the memory management system. By anticipating data access patterns through advanced heuristics, the system significantly reduces latency and improves overall throughput. Sophisticated garbage collection algorithms work in concert with these systems, minimizing memory fragmentation while optimizing resource utilization.
                        </p>

                        <p>
                            Memory coherence across distributed systems presents unique challenges in neural network architectures. Advanced synchronization protocols maintain consistency while minimizing communication overhead. Through innovative approaches to data locality and transfer optimization, the system achieves remarkable efficiency in distributed memory operations.
                        </p>

                        <div class="feature-grid">
                            <div class="feature-item">
                                <h3>Memory Systems</h3>
                                <ul>
                                    <li><strong>Cache Hierarchy:</strong> Multi-level caching</li>
                                    <li><strong>Predictive Loading:</strong> Smart prefetching</li>
                                    <li><strong>Garbage Collection:</strong> Automated cleanup</li>
                                    <li><strong>Memory Pooling:</strong> Resource sharing</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h3>Optimization</h3>
                                <ul>
                                    <li><strong>Access Patterns:</strong> Pattern recognition</li>
                                    <li><strong>Data Locality:</strong> Location optimization</li>
                                    <li><strong>Transfer Rates:</strong> Bandwidth management</li>
                                    <li><strong>Coherence:</strong> Consistency protocols</li>
                                </ul>
                            </div>
                            </div>

                        <h2>Processing Pipeline</h2>
                        <p>
                            Computational efficiency in neural networks requires sophisticated pipeline optimization. Advanced instruction scheduling algorithms analyze dependencies and resource availability in real-time, automatically adjusting execution strategies. This dynamic approach ensures optimal resource utilization while maintaining processing consistency across diverse workloads.
                        </p>

                        <p>
                            Parallel execution capabilities leverage sophisticated hardware features through intelligent abstraction layers. By automatically identifying opportunities for concurrent processing, the system maximizes throughput across available computing resources. Advanced scheduling algorithms ensure efficient distribution of computational tasks while maintaining optimal resource utilization.
                        </p>

                        <p>
                            Pipeline stages undergo continuous optimization through sophisticated monitoring and analysis. Real-time performance metrics drive dynamic adjustments to execution strategies, ensuring peak efficiency across varying workload conditions. Through innovative approaches to instruction reordering and resource allocation, the system achieves unprecedented levels of processing efficiency.
                        </p>

                        <div class="feature-grid">
                            <div class="feature-item">
                                <h3>Pipeline Features</h3>
                                <ul>
                                    <li><strong>Instruction Scheduling:</strong> Dynamic ordering</li>
                                    <li><strong>Resource Allocation:</strong> Optimal distribution</li>
                                    <li><strong>Parallel Processing:</strong> Concurrent execution</li>
                                    <li><strong>Performance Monitoring:</strong> Real-time analysis</li>
                                </ul>
                        </div>
                            <div class="feature-item">
                                <h3>Optimization</h3>
                                <ul>
                                    <li><strong>Execution Strategy:</strong> Adaptive processing</li>
                                    <li><strong>Resource Usage:</strong> Efficient utilization</li>
                                    <li><strong>Task Distribution:</strong> Load balancing</li>
                                    <li><strong>Pipeline Stages:</strong> Stage optimization</li>
                                </ul>
                    </div>
                        </div>

                        <h2>Distribution System</h2>
                        <p>
                            Modern neural networks increasingly demand sophisticated approaches to distributed computing. Advanced protocols for workload distribution and state synchronization form the core of the distribution system. Through innovative approaches to task partitioning and resource allocation, the system achieves remarkable efficiency in distributed operations.
                        </p>

                        <p>
                            Load balancing strategies leverage sophisticated algorithms for workload analysis and distribution. Real-time monitoring of system conditions drives dynamic adjustments to distribution patterns, ensuring optimal resource utilization across the network. Advanced fault tolerance mechanisms maintain system stability while enabling seamless scaling of distributed operations.
                        </p>

                        <p>
                            Network optimization plays a crucial role in distributed system performance. Sophisticated protocols minimize communication overhead while maintaining system coherence. Through innovative approaches to data transfer and synchronization, the system achieves remarkable efficiency in network operations.
                        </p>

                        <div class="feature-grid">
                            <div class="feature-item">
                                <h3>Distribution Features</h3>
                                <ul>
                                    <li><strong>Workload Distribution:</strong> Task allocation</li>
                                    <li><strong>State Synchronization:</strong> Consistency management</li>
                                    <li><strong>Fault Tolerance:</strong> Error handling</li>
                                    <li><strong>Network Optimization:</strong> Communication efficiency</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h3>System Management</h3>
                                <ul>
                                    <li><strong>Load Balancing:</strong> Resource distribution</li>
                                    <li><strong>Monitoring:</strong> System analysis</li>
                                    <li><strong>Scaling:</strong> Dynamic adjustment</li>
                                    <li><strong>Recovery:</strong> System restoration</li>
                                </ul>
                            </div>
                        </div>
                    </section>
                `
            },
            'state-management': {
                title: 'State Management',
                content: `
                    <header class="docs-header">
                        <h1 class="docs-title">State Management</h1>
                        <p class="docs-description">Advanced state handling and synchronization</p>
                    </header>
                    
                    <section class="api-section">
                        <h2>Core Concepts</h2>
                        <p>
                            State management in autonomous systems presents unique challenges that traditional approaches fail to address. The framework implements a revolutionary distributed state model that maintains consistency across complex neural networks while enabling real-time updates and synchronization. Through sophisticated versioning and conflict resolution mechanisms, the system ensures data integrity even during concurrent operations.
                        </p>

                        <p>
                            Breaking from conventional state management patterns, the system introduces a multi-layered approach to data consistency. Each layer operates independently while maintaining synchronization through advanced protocols. This architectural design enables unprecedented flexibility in handling diverse state requirements across different components of the system.
                        </p>

                        <div class="feature-grid">
                            <div class="feature-item">
                                <h3>State Layers</h3>
                                <ul>
                                    <li><strong>Ephemeral State:</strong> Temporary runtime data</li>
                                    <li><strong>Persistent State:</strong> Long-term storage</li>
                                    <li><strong>Distributed State:</strong> Network-wide consistency</li>
                                    <li><strong>Cached State:</strong> Performance optimization</li>
                                </ul>
                            </div>
                            <div class="feature-item">
                                <h3>Key Features</h3>
                                <ul>
                                    <li><strong>Version Control:</strong> State history tracking</li>
                                    <li><strong>Conflict Resolution:</strong> Automatic merging</li>
                                    <li><strong>Real-time Updates:</strong> Immediate propagation</li>
                                    <li><strong>Rollback Support:</strong> State recovery</li>
                                </ul>
                            </div>
                        </div>

                        <h2>State Synchronization</h2>
                        <p>
                            Maintaining state consistency across distributed systems requires sophisticated synchronization mechanisms. The framework implements advanced protocols that ensure state coherence while minimizing communication overhead. Through intelligent batching and differential updates, the system achieves remarkable efficiency in state propagation across network boundaries.
                        </p>

                        <p>
                            State conflicts in distributed environments present complex challenges for system stability. Advanced conflict resolution algorithms analyze state changes and automatically merge updates when possible. In cases where automatic resolution isn't feasible, the system provides sophisticated mechanisms for manual intervention and state reconciliation.
                        </p>

                        <p>
                            Performance optimization in state synchronization relies on intelligent caching and prefetching mechanisms. The system analyzes access patterns and automatically adjusts caching strategies to minimize latency and reduce network load. This dynamic approach ensures optimal performance even under varying operational conditions.
                        </p>

                        <h2>Version Control</h2>
                        <p>
                            State versioning enables sophisticated tracking and management of system evolution. Through advanced version control mechanisms, the system maintains detailed history of state changes while enabling efficient navigation through different versions. This capability proves crucial for debugging, audit trails, and system recovery operations.
                        </p>

                        <p>
                            Branching and merging operations receive special attention in the version control system. Sophisticated algorithms analyze state dependencies and automatically resolve conflicts during merge operations. This automated approach significantly reduces the complexity of managing concurrent state modifications across distributed systems.
                        </p>

                        <h2>Recovery Mechanisms</h2>
                        <p>
                            System reliability depends heavily on robust state recovery capabilities. The framework implements sophisticated checkpoint and rollback mechanisms that enable rapid recovery from failures while maintaining data consistency. Through intelligent state serialization and storage strategies, the system minimizes recovery time while ensuring data integrity.
                        </p>

                        <p>
                            Incremental state backup mechanisms optimize storage utilization while maintaining comprehensive recovery capabilities. The system automatically manages backup frequency and retention based on state volatility and system requirements. This dynamic approach ensures optimal resource utilization while maintaining robust recovery capabilities.
                        </p>

                        <h2>Performance Optimization</h2>
                        <p>
                            State access patterns significantly impact system performance. Advanced caching mechanisms analyze access patterns and automatically adjust caching strategies to optimize performance. Through sophisticated prefetching algorithms, the system minimizes access latency while maintaining memory efficiency.
                        </p>

                        <p>
                            Resource utilization receives careful consideration in state management operations. The system implements advanced garbage collection and state compression algorithms that optimize storage utilization while maintaining access performance. This balanced approach ensures efficient resource usage without compromising system responsiveness.
                        </p>

                        <h2>Security Integration</h2>
                        <p>
                            State security requires comprehensive protection mechanisms across all system layers. Advanced encryption algorithms secure state data both at rest and in transit, while sophisticated access control mechanisms ensure proper authorization for state modifications. Through careful integration of security protocols, the system maintains data protection without compromising performance.
                        </p>

                        <p>
                            Audit capabilities provide crucial oversight for state operations. The system maintains detailed logs of state modifications, including timing, source, and nature of changes. This comprehensive tracking enables sophisticated analysis of system behavior while supporting compliance requirements.
                        </p>

                        <h2>Monitoring and Analytics</h2>
                        <p>
                            Real-time monitoring of state operations provides crucial insights into system behavior. Advanced analytics tools analyze state access patterns and system performance metrics, enabling proactive optimization of state management strategies. Through sophisticated visualization and reporting capabilities, the system supports detailed analysis of state operations.
                        </p>

                        <p>
                            Performance metrics receive careful attention in the monitoring system. Sophisticated tools track key indicators including access latency, synchronization overhead, and resource utilization. This comprehensive monitoring enables continuous optimization of state management operations while maintaining system reliability.
                    </p>
                </section>
            `
        },
            'vector-operations': {
                title: 'Vector Operations',
            content: `
                <header class="docs-header">
                        <h1 class="docs-title">Vector Operations</h1>
                        <p class="docs-description">Low-level vector computation and memory management</p>
                </header>
                
                <section class="api-section">
                        <h2>Implementation Details</h2>
                        <p>
                            Vector operations are implemented using SIMD (Single Instruction Multiple Data) instructions when available, falling back to scalar operations on unsupported architectures. The primary vector unit operates on 256-bit registers using AVX2 instructions, processing 8 single-precision or 4 double-precision floating point numbers per cycle.
                        </p>

                        <p>
                            Memory alignment is critical for SIMD performance. Vectors are aligned on 32-byte boundaries by default, with a performance penalty of approximately 15% for unaligned access. The allocator uses a buddy system with power-of-two block sizes to maintain alignment while minimizing fragmentation.
                        </p>

                        <div class="code-example">
                            <pre><code class="language-cpp">
// Example of internal vector alignment
struct alignas(32) Vector {
    float data[8];  // Aligned for AVX2
    size_t size;    // Actual data size
    uint8_t flags;  // Metadata flags
};
                            </code></pre>
                        </div>

                        <h2>Memory Layout</h2>
                        <p>
                            Vectors use a Structure of Arrays (SoA) layout rather than Array of Structures (AoS) to maximize cache efficiency and SIMD utilization. For N-dimensional vectors, components are stored in contiguous memory blocks:
                        </p>

                        <div class="code-example">
                            <pre><code class="language-text">
Memory Layout (32-byte aligned):
[x1 x2 x3 x4 x5 x6 x7 x8] // x components
[y1 y2 y3 y4 y5 y6 y7 y8] // y components
[z1 z2 z3 z4 z5 z6 z7 z8] // z components
                            </code></pre>
                        </div>

                        <p>
                            This layout allows for efficient vectorized operations but incurs a 12% performance penalty for random access patterns. The tradeoff is justified by the 3.2x speedup in common operations like dot products and transformations.
                        </p>

                        <h2>Cache Optimization</h2>
                        <p>
                            Vector operations are optimized for L1 cache utilization. The default block size of 1024 elements (4KB) aligns with common L1 cache line sizes. Operations on larger vectors are automatically tiled to maintain cache efficiency:
                        </p>

                        <div class="code-example">
                            <pre><code class="language-cpp">
// Internal block processing
void process_blocks(float* data, size_t n) {
    const size_t block_size = 1024;  // L1 cache optimized
    for (size_t i = 0; i < n; i += block_size) {
        size_t chunk = min(block_size, n - i);
        process_block(data + i, chunk);
    }
}
                            </code></pre>
                        </div>

                        <h2>Numerical Stability</h2>
                        <p>
                            Floating point operations use Kahan summation for large vector reductions, trading a 4% performance penalty for numerical stability. Double-precision operations are used internally for accumulators to minimize error propagation:
                        </p>

                        <div class="code-example">
                            <pre><code class="language-cpp">
// Internal Kahan summation implementation
double vector_sum(const float* data, size_t n) {
    double sum = 0.0;
    double c = 0.0;  // Running compensation
    for (size_t i = 0; i < n; ++i) {
        double y = data[i] - c;
        double t = sum + y;
        c = (t - sum) - y;
        sum = t;
    }
    return sum;
}
                            </code></pre>
                        </div>

                        <h2>Performance Characteristics</h2>
                        <p>
                            Operation latencies on typical x86_64 hardware with AVX2:
                        </p>

                        <ul>
                            <li>Vector addition: 1.2 cycles/element</li>
                            <li>Dot product: 2.8 cycles/element</li>
                            <li>Cross product: 4.1 cycles/element</li>
                            <li>Matrix-vector multiply: 3.5 cycles/element</li>
                        </ul>

                        <p>
                            Memory bandwidth becomes the primary bottleneck for vectors larger than L3 cache (typically 8MB). Performance drops by approximately 65% when operations become memory-bound.
                        </p>

                        <h2>Threading Model</h2>
                        <p>
                            Vector operations use a work-stealing thread pool for parallelization. The minimum partition size is 4096 elements to amortize threading overhead. Smaller vectors are processed single-threaded to avoid synchronization costs:
                        </p>

                        <div class="code-example">
                            <pre><code class="language-cpp">
// Parallel processing threshold
static constexpr size_t MIN_PARALLEL_SIZE = 4096;
static constexpr size_t MIN_PARTITION_SIZE = 512;

size_t partition_size = max(
    MIN_PARTITION_SIZE,
    vec_size / (thread_pool.size() * 4)
);
                            </code></pre>
                        </div>

                        <h2>Hardware Limitations</h2>
                        <p>
                            Known hardware-specific limitations and workarounds:
                        </p>

                        <ul>
                            <li>AMD Zen 1/2: 256-bit operations are split into 128-bit, requiring manual vectorization hints</li>
                            <li>Intel pre-Skylake: crossing 256-bit boundaries incurs additional latency</li>
                            <li>ARM NEON: limited to 128-bit operations, requires separate code path</li>
                        </ul>

                        <h2>Error Handling</h2>
                        <p>
                            Vector operations use error codes rather than exceptions for performance. Common error conditions:
                        </p>

                        <div class="code-example">
                            <pre><code class="language-cpp">
enum VectorError {
    SUCCESS = 0,
    MISALIGNED_MEMORY = 1,    // Memory not 32-byte aligned
    DIMENSION_MISMATCH = 2,   // Vector size mismatch
    INVALID_OPERATION = 3,    // e.g., zero division
    INSUFFICIENT_MEMORY = 4,  // Allocation failed
};
                            </code></pre>
                        </div>

                        <p>
                            Error checking can be disabled at compile time for maximum performance, reducing operation latency by 8-12% at the cost of safety.
                        </p>
                    </section>
                `
            },
            'memory-system': {
                title: 'Memory System',
                content: `
                    <header class="docs-header">
                        <h1 class="docs-title">Memory System</h1>
                        <p class="docs-description">Advanced memory management and state persistence</p>
                    </header>
                    
                    <section class="api-section">
                        <h2>Overview</h2>
                        <p>VAE's memory system represents a sophisticated approach to managing state, context, and learned information across multiple time scales. Unlike traditional memory management systems that focus solely on data persistence, VAE implements a cognitive-inspired architecture that mirrors human memory processes, allowing for more nuanced and context-aware information processing.</p>
                        
                        <p>The system is built on a three-tier architecture that balances performance, persistence, and accessibility. Each tier serves a specific purpose in the overall cognitive architecture, working together to create a cohesive and efficient memory management solution. This approach enables VAE to maintain context across long conversations, learn from past interactions, and make informed decisions based on historical data.</p>

                    <div class="system-diagram">
                            
                        <svg width="100%" height="400" viewBox="0 0 1000 300" preserveAspectRatio="xMidYMid meet">
                                <!-- Short-term Memory -->
                            <g transform="translate(100,50)">
                                <rect width="200" height="200" rx="6" fill="rgba(0,0,0,0.4)" stroke="rgba(255,255,255,0.12)" stroke-width="1"/>
                                    <text x="100" y="40" fill="rgba(255,255,255,0.95)" font-size="16" text-anchor="middle">Short-term Memory</text>
                                <line x1="20" y1="60" x2="180" y2="60" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                                    <text x="100" y="90" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Active Context</text>
                                    <text x="100" y="120" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Recent Events</text>
                                    <text x="100" y="150" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Temp Cache</text>
                                </g>

                                <!-- Working Memory -->
                            <g transform="translate(400,50)">
                                <rect width="200" height="200" rx="6" fill="rgba(0,0,0,0.4)" stroke="rgba(255,255,255,0.12)" stroke-width="1"/>
                                    <text x="100" y="40" fill="rgba(255,255,255,0.95)" font-size="16" text-anchor="middle">Working Memory</text>
                                <line x1="20" y1="60" x2="180" y2="60" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                                    <text x="100" y="90" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Session State</text>
                                    <text x="100" y="120" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Task History</text>
                                    <text x="100" y="150" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">User Context</text>
                                </g>

                                <!-- Long-term Memory -->
                            <g transform="translate(700,50)">
                                <rect width="200" height="200" rx="6" fill="rgba(0,0,0,0.4)" stroke="rgba(255,255,255,0.12)" stroke-width="1"/>
                                    <text x="100" y="40" fill="rgba(255,255,255,0.95)" font-size="16" text-anchor="middle">Long-term Memory</text>
                                <line x1="20" y1="60" x2="180" y2="60" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                                    <text x="100" y="90" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Knowledge Base</text>
                                    <text x="100" y="120" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Learned Patterns</text>
                                    <text x="100" y="150" fill="rgba(255,255,255,0.6)" font-size="14" text-anchor="middle">Historical Data</text>
                            </g>

                            <!-- Connecting Lines -->
                            <g stroke="rgba(255,255,255,0.2)" stroke-width="1">
                                <path d="M 300 150 L 400 150"/>
                                <path d="M 600 150 L 700 150"/>
                            </g>
                        </svg>
                    </div>

                        <h2>Memory Tiers In Depth</h2>
                        
                        <h3>Short-term Memory (STM)</h3>
                        <p>The short-term memory system in VAE serves as the primary interface for immediate context and rapid information processing. Similar to human working memory, it maintains a limited but highly accessible set of information that's crucial for ongoing operations. This tier is implemented using Redis, chosen specifically for its sub-millisecond response times and flexible data structures.</p>
                        
                        <p>Short-term memory is particularly crucial for maintaining conversation coherence and context awareness. When processing user interactions, the STM keeps track of recent exchanges, temporary variables, and immediate context that might influence the next response. This includes:</p>
                        
                        <ul>
                            <li><strong>Active Context Windows:</strong> Maintains the last N exchanges in a conversation, allowing for coherent back-and-forth interaction without losing context. The size of this window is dynamically adjusted based on the complexity of the conversation and available system resources.</li>
                            
                            <li><strong>Temporary Variables:</strong> Holds intermediate calculation results, temporary flags, and other ephemeral data needed for ongoing operations. These are automatically cleaned up when no longer needed, preventing memory leaks.</li>
                            
                            <li><strong>Cache Layer:</strong> Implements a sophisticated caching mechanism for frequently accessed data from deeper memory tiers. This cache uses a combination of LRU (Least Recently Used) and frequency-based eviction policies to optimize hit rates.</li>
                        </ul>

                        <h3>Working Memory</h3>
                        <p>Working memory represents the intermediate tier in VAE's memory hierarchy, bridging the gap between volatile short-term memory and persistent long-term storage. This tier is crucial for maintaining operational continuity and managing ongoing processes that span multiple interactions or require medium-term state preservation.</p>

                        <p>The working memory implementation uses PostgreSQL, leveraging its robust ACID properties and rich query capabilities. This choice allows for complex state management while ensuring data consistency and reliability. The working memory system includes several sophisticated components:</p>

                        <ul>
                            <li><strong>Session Management Engine:</strong> Maintains user sessions and their associated states, including preferences, authentication tokens, and interaction history. The session manager implements adaptive timeout policies based on user activity patterns and system load.</li>
                            
                            <li><strong>Task Coordination System:</strong> Handles long-running operations and maintains their state across system restarts or failures. This includes checkpoint management, progress tracking, and automatic recovery mechanisms.</li>
                            
                            <li><strong>Context Window Manager:</strong> Implements a sliding window of relevant context that's larger than what's maintained in short-term memory but more focused than long-term storage. This manager uses sophisticated algorithms to determine what information should be kept readily available versus what can be archived.</li>
                        </ul>

                        <h3>Long-term Memory (LTM)</h3>
                        <p>The long-term memory system represents VAE's persistent knowledge store, implementing sophisticated mechanisms for storing, retrieving, and organizing information over extended periods. This tier is built on a vector store foundation, enabling semantic search and pattern matching capabilities that go beyond simple key-value lookups.</p>

                        <p>Long-term memory in VAE is not just a passive storage system but an active component that contributes to the system's learning and decision-making processes. It implements several advanced features:</p>

                        <ul>
                            <li><strong>Knowledge Graph Integration:</strong> Information is stored not just as isolated data points but as part of an interconnected knowledge graph. This allows for sophisticated reasoning and inference capabilities, enabling VAE to make connections between related pieces of information even when they're not explicitly linked.</li>
                            
                            <li><strong>Pattern Recognition System:</strong> The LTM continuously analyzes stored information to identify recurring patterns, common scenarios, and frequently used information. These patterns are used to optimize response generation and decision-making processes.</li>
                            
                            <li><strong>Semantic Indexing:</strong> Implements advanced indexing strategies that go beyond traditional database indexes. The semantic indexing system uses transformer-based embeddings to create high-dimensional representations of stored information, enabling nuanced similarity searches and pattern matching.</li>
                        </ul>

                        <h2>Memory Management Strategies</h2>
                        <p>VAE's memory management system implements sophisticated strategies for maintaining optimal performance while ensuring data integrity and availability. These strategies are continuously refined based on system usage patterns and performance metrics.</p>

                        <h3>Adaptive Memory Allocation</h3>
                        <p>The system implements dynamic memory allocation strategies that adapt to changing workloads and system conditions. This includes:</p>

                        <ul>
                            <li><strong>Load-Based Scaling:</strong> Memory allocations are automatically adjusted based on system load and usage patterns. During high-load periods, the system may increase cache sizes and working memory allocations to maintain performance.</li>
                            
                            <li><strong>Priority-Based Management:</strong> Not all data is treated equally. The system maintains priority levels for different types of information, ensuring that critical data remains readily accessible while less important information may be moved to slower storage tiers.</li>
                            
                            <li><strong>Predictive Loading:</strong> Based on usage patterns and context, the system can predictively load information that's likely to be needed, reducing response times for common operations.</li>
                        </ul>

                        <h3>Data Migration Policies</h3>
                        <p>The movement of data between memory tiers is governed by sophisticated policies that balance performance, resource utilization, and data importance. These policies consider multiple factors:</p>

                        <ul>
                            <li><strong>Access Patterns:</strong> Frequently accessed data may be promoted to faster memory tiers, while rarely accessed information is moved to long-term storage.</li>
                            
                            <li><strong>Semantic Importance:</strong> The system evaluates the semantic importance of information when making migration decisions. Critical context or frequently referenced knowledge may be kept in more accessible tiers even if not recently accessed.</li>
                            
                            <li><strong>Resource Constraints:</strong> Migration policies adapt to available system resources, implementing more aggressive archival strategies when resources are constrained.</li>
                        </ul>

                        <h2>Advanced Usage Patterns</h2>
                        <p>While the basic memory system API provides straightforward access to common operations, VAE also supports advanced usage patterns for specialized needs:</p>

                        <h3>Custom Memory Handlers</h3>
                        <p>The memory system can be extended with custom handlers for specialized data types or storage requirements. This allows for integration with domain-specific storage solutions or implementation of custom caching strategies. Custom handlers must implement the standard memory interface while providing additional functionality for specific use cases.</p>

                        <h3>Transaction Management</h3>
                        <p>For operations that span multiple memory tiers, VAE provides transaction management capabilities that ensure data consistency. This includes support for distributed transactions when working with multiple storage backends, with automatic rollback in case of failures.</p>

                        <h3>Event-Driven Updates</h3>
                        <p>The memory system implements an event-driven architecture that allows components to subscribe to memory-related events. This enables reactive updating of dependent components and maintains consistency across the system when memory contents change.</p>
                    </section>
                `
            },
            'llm-integration': {
                title: 'LLM Integration',
                content: `
                    <header class="docs-header">
                        <h1 class="docs-title">LLM Integration</h1>
                        <p class="docs-description">Low-level LLM interfacing and optimization</p>
                    </header>
                    
                    <section class="api-section">
                        <h2>Token Management</h2>
                        <p>
                            Token processing uses a byte-pair encoding (BPE) tokenizer with a 50,257 token vocabulary. The tokenizer implements incremental encoding to avoid re-tokenizing the entire context window on each update. This optimization reduces CPU overhead by 73% compared to full window tokenization, at the cost of a 2.1MB memory overhead for partial token trees.
                        </p>

                        <p>
                            The tokenizer maintains a sliding window of the last 512 tokens to handle cross-boundary token merges. This window size was chosen based on empirical analysis showing that 99.97% of all multi-token sequences are captured within this range. Increasing the window size provides diminishing returns while linearly increasing memory usage.
                        </p>

                        <div class="code-example">
                            <pre><code class="language-cpp">
struct TokenBuffer {
    uint32_t* tokens;      // Circular buffer of token IDs
    size_t capacity;       // Power of 2 for fast modulo
    size_t head;          // Write position
    size_t tail;          // Read position
    uint32_t flags;       // Buffer state flags
};

// Token buffer initialization with alignment
TokenBuffer* create_buffer(size_t size) {
    size_t aligned_size = next_power_of_2(size);
    void* ptr = aligned_alloc(64, aligned_size * sizeof(uint32_t));
    // ... initialization code
}
                            </code></pre>
</div>

                        <p>
                            Token buffers use a circular implementation to avoid memory copies during window slides. The buffer size is always a power of 2 to replace modulo operations with bit masks, reducing access latency by approximately 15%. This optimization is particularly important for high-throughput scenarios where token buffer access can become a bottleneck.
                        </p>

                        <h2>Memory Management</h2>
                        <p>
                            The KV-cache implements a two-level hierarchy to balance access speed with capacity. L1 cache in GPU memory provides 0.8ms average access latency but is limited to 8GB, while L2 cache in system memory offers 4.2ms latency with capacity limited only by available RAM. Cache entries are carefully aligned to avoid straddling cache lines, which would otherwise introduce additional memory fetches.
                        </p>

                        <p>
                            Cache eviction uses a hybrid strategy combining LRU with a score-based system that considers token frequency and position. Frequently accessed tokens near the start of the context window receive higher retention priority. This approach improves cache hit rates by 12% compared to pure LRU, particularly for long-running conversations.
</p>

<div class="code-example">
                            <pre><code class="language-cpp">
struct CacheEntry {
    float* k_values;        // Key cache, GPU memory
    float* v_values;        // Value cache, GPU memory
    uint32_t token_id;      // Associated token
    uint32_t timestamp;     // LRU tracking
    uint16_t layer_idx;     // Model layer
    uint16_t flags;         // Entry state
} __attribute__((aligned(16)));

// Cache statistics for last 1M requests:
// Hit rate: 76.3% (L1), 94.8% (L2)
// Eviction rate: 12.4% (L1), 3.2% (L2)
// Average latency: 0.8ms (L1), 4.2ms (L2)
    </code></pre>
</div>

<p>
                            Cache coherency between L1 and L2 is maintained through a write-through policy with a write buffer to batch updates. The write buffer is flushed either when full (256KB) or after a 5ms timeout, whichever occurs first. This batching reduces PCIe bus transactions by 83% while adding only 2.5ms average latency to L2 updates.
                        </p>

                        <h2>Batch Processing</h2>
                        <p>
                            The batching system dynamically adjusts batch sizes based on current GPU utilization and PCIe bandwidth availability. A token count threshold prevents excessive latency from large requests, while a request count limit manages memory usage. The timeout ensures responsiveness during low-traffic periods where optimal batch sizes might not be reached.
                        </p>

                        <p>
                            Batch composition considers token length distribution to maximize GPU utilization. Requests are sorted into bins based on token count, allowing the batcher to construct optimally-sized batches even when individual request sizes vary significantly. This approach improves GPU utilization by 23% compared to simple FIFO batching.
</p>

<div class="code-example">
    <pre><code class="language-cpp">
// Batch configuration parameters
struct BatchConfig {
    uint32_t max_tokens;     // Maximum tokens per batch
    uint32_t max_requests;   // Maximum requests per batch
    float timeout_ms;        // Max wait time for batching
    float target_util;       // Target GPU utilization
};

// Default configuration (tuned for A100 GPU)
BatchConfig default_config = {
    .max_tokens = 8192,      // Optimized for 16GB VRAM
    .max_requests = 64,      // Based on PCIe bandwidth
    .timeout_ms = 5.0f,      // Latency constraint
    .target_util = 0.8f      // GPU utilization target
};
    </code></pre>
</div>

                        <p>
                            Batch scheduling uses a work-stealing algorithm to balance load across multiple GPU devices. Each device maintains a local queue, but can steal batches from other devices when idle. This approach reduces average latency by 34% compared to fixed device assignment, particularly during uneven load distribution.
                        </p>

                        <h2>Error Handling</h2>
                        <p>
                            The error handling system uses error codes rather than exceptions to avoid the performance overhead of exception handling. Each error type includes additional context data to aid in debugging and recovery. Error logging includes stack traces for critical errors while maintaining a circular buffer of recent non-critical errors to aid in pattern detection.
</p>

<div class="code-example">
    <pre><code class="language-cpp">
enum LLMError {
    SUCCESS = 0,
    TOKEN_OVERFLOW = 1,        // Context window exceeded
    BATCH_TIMEOUT = 2,         // Batch wait timeout
    GPU_MEMORY_ERROR = 3,      // CUDA allocation failed
    INVALID_MODEL_STATE = 4,   // Model corruption detected
    RATE_LIMITED = 5           // API rate limit hit
};

// Error rates (per 1M requests):
// TOKEN_OVERFLOW:     2,341 (0.23%)
// BATCH_TIMEOUT:      1,892 (0.19%)
// GPU_MEMORY_ERROR:     156 (0.02%)
// INVALID_MODEL_STATE:    12 (0.001%)
// RATE_LIMITED:       4,523 (0.45%)
    </code></pre>
</div>

                        <p>
                            Error recovery implements a multi-stage fallback system. For GPU memory errors, the system attempts to free cache memory before failing. Batch timeouts trigger automatic batch size adjustment. Rate limiting implements exponential backoff with jitter to prevent thundering herd problems during recovery.
                        </p>

                        <h2>Performance Optimization</h2>
                        <p>
                            Key performance metrics and optimization strategies:
</p>

<ul>
                            <li>Token throughput: 2,048 tokens/sec per A100 GPU</li>
                            <li>Batch latency: 15-45ms depending on batch size</li>
                            <li>Memory usage: 14.7GB VRAM for base model</li>
                            <li>PCI-e bandwidth utilization: 22.4 GB/s peak</li>
</ul>

<p>
                            Performance bottlenecks by operation:
                        </p>

                        <div class="code-example">
                            <pre><code class="language-text">
Operation               | Time (ms) | Bottleneck
---------------------- | --------- | ----------
Token encoding         |     0.8   | CPU bound
KV-cache lookup       |     1.2   | Memory bound
Attention compute     |    12.4   | Compute bound
Token generation      |     4.3   | Compute bound
Memory transfers      |     2.1   | PCIe bound
                            </code></pre>
                        </div>

                        <h2>Resource Limits</h2>
                        <p>
                            System resource constraints and limitations:
</p>

<div class="code-example">
    <pre><code class="language-cpp">
// Resource limits per instance
struct ResourceLimits {
    uint32_t max_context_length;    // 8192 tokens
    uint32_t max_batch_size;        // 64 requests
    uint32_t max_tokens_per_req;    // 1024 tokens
    size_t max_gpu_memory;          // 14.7GB
    float max_req_per_sec;          // 256 req/s
};

// Memory allocation by component:
// - Model weights:    11.3GB
// - KV cache:         2.8GB
// - Scratch space:    0.6GB
// - Token buffers:    0.2GB
    </code></pre>
</div>

                        <h2>API Rate Limiting</h2>
                        <p>
                            Rate limiting uses a token bucket algorithm with the following parameters:
                        </p>

                        <div class="code-example">
                            <pre><code class="language-cpp">
struct RateLimiter {
    uint32_t tokens_per_sec;    // Base rate
    uint32_t burst_tokens;      // Burst capacity
    float token_value;          // Cost per request
    uint64_t last_update;       // Last refill time
};

// Default limits (per API key):
// - Base rate: 256 requests/sec
// - Burst rate: 512 requests/sec
// - Decay rate: 0.5 tokens/sec
// - Recovery time: 120 seconds
                            </code></pre>
                        </div>

                        <h2>Monitoring Metrics</h2>
                        <p>
                            Key metrics collected per 5-second interval:
</p>

<div class="code-example">
    <pre><code class="language-cpp">
struct Metrics {
    // Request metrics
    uint32_t requests_processed;
    uint32_t tokens_generated;
    uint32_t batch_count;
    
    // Performance metrics
    float avg_latency_ms;
    float p95_latency_ms;
    float gpu_utilization;
    
    // Error metrics
    uint32_t errors_by_type[6];
    float error_rate;
    
    // Resource metrics
    float gpu_memory_used;
    float cpu_memory_used;
    float pcie_bandwidth;
};
    </code></pre>
</div>
                    </section>
                `
            },
            'plugins': {
                title: 'Plugin System',
                content: `
                    <header class="docs-header">
                        <h1 class="docs-title">Plugin System</h1>
                        <p class="docs-description">Extensible agent capabilities</p>
                    </header>
                    
                    <section class="api-section">
                        <h2>Overview</h2>
                        <p>The VAE plugin system represents a fundamental shift in how AI frameworks handle extensibility. Unlike traditional plugin architectures that simply allow for additional features, VAE's system is built on the principle of dynamic capability expansion. This means plugins can not only add new functionality but can also modify and enhance existing capabilities at runtime.</p>
                        
                        <p>At its core, the plugin system utilizes a sophisticated event propagation model that allows for bidirectional communication between plugins and the core system. This enables plugins to not just respond to system events, but to actively participate in the decision-making process of the AI framework.</p>

                        <h2>Core Architecture</h2>
                        <p>The plugin architecture is built around three fundamental principles: isolation, communication, and state management. Each plugin operates within its own isolated context, preventing unwanted side effects while still maintaining the ability to interact with other components through well-defined interfaces.</p>

                        <h2>Memory Isolation</h2>
                        <p>Memory isolation in the plugin system goes beyond simple process separation. Each plugin maintains its own memory space with a sophisticated garbage collection system that understands both the plugin's local state and its relationships with other components. This system employs a reference-counting mechanism with cycle detection to prevent memory leaks, while also maintaining weak references to shared resources.</p>
                        
                        <p>The isolation system implements a hierarchical memory model where plugins can define different levels of state persistence:</p>
                        
                        <p>Ephemeral State represents temporary data that exists only during specific operations. This includes intermediate calculations, temporary buffers, and short-lived caches. The system automatically cleans up this state based on scope exit or explicit triggers.</p>
                        
                        <p>Session State encompasses data that persists throughout a single runtime session. This includes configuration settings, cached results, and runtime optimizations. The system maintains this state until explicit cleanup or system shutdown.</p>
                        
                        <p>Persistent State handles long-term data that survives across sessions. This includes learned patterns, user preferences, and historical data. The system provides automatic serialization and deserialization with versioning support.</p>

                        <h2>Event Propagation</h2>
                        <p>The event system in VAE plugins implements a sophisticated propagation model that goes beyond simple event emission and handling. Events flow through a multi-stage pipeline that allows for event transformation, filtering, and prioritization.</p>
                        
                        <p>When an event is emitted, it goes through several stages. First, events traverse down the plugin hierarchy during the Capture Phase, allowing parent plugins to intercept and potentially modify events before they reach their target. This enables sophisticated event preprocessing and validation.</p>
                        
                        <p>Next, in the Target Phase, the event reaches its intended recipient, where it can be processed and potentially transformed. During this phase, plugins can access both the original event data and any modifications made during the capture phase.</p>
                        
                        <p>Finally, during the Bubble Phase, events bubble back up through the hierarchy, allowing for post-processing and reaction from parent plugins. This enables complex workflows where multiple plugins can coordinate their responses to events.</p>
                        
                        <p>The event system also implements a priority queue mechanism that ensures critical events are processed before less important ones. This priority system is dynamic and can be adjusted based on system load and plugin states.</p>

                        <h2>State Synchronization</h2>
                        <p>State synchronization in the plugin system employs a sophisticated conflict resolution mechanism based on vector clocks and causal consistency. This ensures that even in distributed environments, plugin states remain coherent and updates are applied in a causally consistent manner.</p>
                        
                        <p>Each state modification is tagged with a vector timestamp that captures the causal relationships between updates. This allows the system to detect and resolve conflicts by understanding the order in which changes occurred.</p>
                        
                        <p>When conflicts are detected, the system employs a sophisticated resolution strategy that considers both the semantic meaning of the updates and their temporal relationships. This goes beyond simple "last-write-wins" approaches and allows for meaningful merge operations.</p>
                        
                        <p>All state changes are versioned, allowing plugins to maintain a history of modifications and implement features like undo/redo or state rollback. The versioning system uses a compact representation that minimizes memory overhead while maintaining full history information.</p>

                        <h2>Implementation Considerations</h2>
                        <p>When implementing plugins for VAE, developers need to consider several critical aspects that affect both performance and reliability. The system provides sophisticated tools for monitoring and optimizing these aspects, but understanding them is crucial for effective plugin development.</p>
                        
                        <p>Resource Management requires plugins to implement proper resource acquisition and release patterns. The system provides RAII-style resource handles that automatically manage cleanup, but developers need to carefully consider resource lifecycles and potential deadlock scenarios.</p>
                        
                        <p>State Persistence should use the system's serialization framework which provides automatic versioning and migration support. This ensures that plugin data can survive version upgrades and system changes.</p>
                        
                        <p>Error Handling in the plugin system implements a sophisticated mechanism that goes beyond simple try-catch blocks. Errors can be categorized, filtered, and handled at different levels of the plugin hierarchy.</p>
                    </section>
                `
            }
        };

        // Keep the original DOMContentLoaded handler for docs
        document.addEventListener('DOMContentLoaded', () => {
            // Original docs initialization code
            const initialSection = window.location.hash.replace('#', '') || 'introduction';
            if (docsContent[initialSection]) {
                document.querySelector('.docs-content').innerHTML = docsContent[initialSection].content;
                const activeLink = document.querySelector(`[href="#${initialSection}"]`);
                if (activeLink) {
                    activeLink.classList.add('active');
                }
        }
        
        // Original link click handlers
        document.querySelectorAll('.docs-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const sectionId = link.getAttribute('href').replace('#', '');
                
                document.querySelectorAll('.docs-link').forEach(l => l.classList.remove('active'));
                link.classList.add('active');
                
                if (docsContent[sectionId]) {
                    document.querySelector('.docs-content').innerHTML = docsContent[sectionId].content;
                    history.pushState(null, '', `#${sectionId}`);
                }
            });
        });
    });

    // Separate initialization for quantum field
    window.addEventListener('load', () => {
        const canvas = document.getElementById('quantumField');
        if (canvas) {
            class QuantumField {
                constructor() {
                    this.canvas = canvas;
                    this.ctx = this.canvas.getContext('2d');
                    // ... rest of QuantumField implementation ...
                }
                    // ... rest of QuantumField methods ...
            }
            new QuantumField();
        }
    });

    // Simple keyword-based search
        const searchInput = document.querySelector('.search-input');
        const searchResults = document.querySelector('.search-results');

    if (searchInput && searchResults) {
        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase().trim();
            
            if (searchTerm === '') {
                searchResults.style.display = 'none';
                return;
            }

            const results = [];
            // Access the global docsContent object
            const docs = window.docsContent || docsContent;
            
            for (const section in docs) {
                const content = docs[section].content.toLowerCase();
                if (content.includes(searchTerm)) {
                    const index = content.indexOf(searchTerm);
                    const previewStart = Math.max(0, index - 50);
                    const previewEnd = Math.min(content.length, index + searchTerm.length + 50);
                    let preview = content.slice(previewStart, previewEnd);
                    
                    if (previewStart > 0) preview = '...' + preview;
                    if (previewEnd < content.length) preview = preview + '...';

                    results.push({
                        title: docs[section].title || section,
                        section: section,
                        preview: preview,
                        searchTerm: searchTerm
                    });
                }
            }

            if (results.length > 0) {
                searchResults.innerHTML = results.map(result => `
                    <div class="search-result-item" data-section="${result.section}" data-term="${result.searchTerm}">
                        <div class="search-result-title">${result.title}</div>
                        <div class="search-result-preview">
                            ${result.preview.replace(
                                new RegExp(result.searchTerm, 'gi'),
                                match => `<span class="search-highlight">${match}</span>`
                            )}
                        </div>
                    </div>
                `).join('');
                
                const searchResultItems = searchResults.querySelectorAll('.search-result-item');
                searchResultItems.forEach(item => {
                    item.addEventListener('click', function() {
                        const section = this.getAttribute('data-section');
                        const searchTerm = this.getAttribute('data-term');
                        
                        // Access the global docsContent object
                        const docs = window.docsContent || docsContent;
                        const docsContentElement = document.querySelector('.docs-content');
                        docsContentElement.innerHTML = docs[section].content;
                        
                        requestAnimationFrame(() => {
                            const walker = document.createTreeWalker(
                                docsContentElement,
                                NodeFilter.SHOW_TEXT,
                                null,
                                false
                            );

                            let node;
                            while (node = walker.nextNode()) {
                                const text = node.textContent.toLowerCase();
                                const termIndex = text.indexOf(searchTerm.toLowerCase());
                                
                                if (termIndex !== -1) {
                                    const span = document.createElement('span');
                                    span.className = 'search-highlight-result';
                                    const range = document.createRange();
                                    range.setStart(node, termIndex);
                                    range.setEnd(node, termIndex + searchTerm.length);
                                    range.surroundContents(span);
                                    
                                    span.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    
                                    span.addEventListener('animationend', () => {
                                        const text = span.textContent;
                                        span.parentNode.replaceChild(document.createTextNode(text), span);
                                    });
                                    
                                    break;
                                }
                            }
                        });

                        searchResults.style.display = 'none';
                        searchInput.value = '';
                        history.pushState(null, '', `#${section}`);
                    });
                });
                
                searchResults.style.display = 'block';
            } else {
                searchResults.innerHTML = '<div class="search-result-item">No results found</div>';
                searchResults.style.display = 'block';
            }
        });

        // Hide results when clicking outside
        document.addEventListener('click', function(e) {
            if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                searchResults.style.display = 'none';
            }
        });
    }

    // Disable version select
    document.addEventListener('DOMContentLoaded', () => {
        const versionSelect = document.querySelector('.version-select');
        if (versionSelect) {
            versionSelect.disabled = true;
            }
        });

        // Add this script to your JavaScript
        document.addEventListener('scroll', () => {
            const scrollProgress = (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100;
            document.querySelector('.scroll-progress-bar').style.height = `${scrollProgress}%`;
            document.querySelector('.scroll-marker').style.top = `${scrollProgress}%`;
        });

        document.addEventListener('DOMContentLoaded', () => {
            const scrollIndicator = document.createElement('div');
            scrollIndicator.className = 'scroll-indicator-container';
            scrollIndicator.innerHTML = `
                <div class="scroll-label">Scroll</div>
                <div class="scroll-progress">
                    <div class="scroll-progress-bar"></div>
                    <div class="scroll-marker"></div>
                </div>
                <div class="scroll-label">Progress</div>
            `;
            document.body.appendChild(scrollIndicator);

            const progressBar = scrollIndicator.querySelector('.scroll-progress-bar');
            const marker = scrollIndicator.querySelector('.scroll-marker');

            window.addEventListener('scroll', () => {
                const windowHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scrolled = (window.scrollY / windowHeight) * 100;
                progressBar.style.height = `${scrolled}%`;
                marker.style.top = `${scrolled}%`;
            });
        });

        // Remove cursor-related code
        document.body.style.cursor = 'default';
        document.querySelectorAll('*').forEach(element => {
            element.style.cursor = 'default';
        });

        // Add cookie notification
    const cookieNotification = document.createElement('div');
    cookieNotification.className = 'cookie-notification';
    cookieNotification.innerHTML = `
        <div class="cookie-content">
            <p>We use cookies to enhance your experience</p>
            <div class="cookie-buttons">
                <button class="cookie-decline">Decline</button>
                <button class="cookie-accept">Accept</button>
</div>
        </div>
    `;
    document.body.appendChild(cookieNotification);

    // Handle cookie preferences
    const cookieAccept = document.querySelector('.cookie-accept');
    const cookieDecline = document.querySelector('.cookie-decline');
    const cookieNotificationElement = document.querySelector('.cookie-notification');

    if (!localStorage.getItem('cookiePreference')) {
        cookieNotificationElement.style.display = 'block';
    }

    cookieAccept.addEventListener('click', () => {
        localStorage.setItem('cookiePreference', 'accepted');
        cookieNotificationElement.style.display = 'none';
    });

    cookieDecline.addEventListener('click', () => {
        localStorage.setItem('cookiePreference', 'declined');
        cookieNotificationElement.style.display = 'none';
    });

    // Add CSS styles for cookie notification
    const cookieStyle = document.createElement('style');
    cookieStyle.textContent = `
        .cookie-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #000000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 20px;
            z-index: 1000;
            display: none;
            width: 320px;
            font-family: 'Chakra Petch', sans-serif;
        }

        .cookie-content p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            letter-spacing: 0.5px;
            margin: 0 0 16px 0;
            text-transform: uppercase;
        }

        .cookie-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .cookie-buttons button {
            padding: 8px 20px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            letter-spacing: 1px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Chakra Petch', sans-serif;
        }

        .cookie-buttons button:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .cookie-accept {
                background: rgba(255, 255, 255, 0.05) !important;
            }

            .cookie-accept:hover {
                background: rgba(255, 255, 255, 0.1) !important;
            }
        `;
        document.head.appendChild(cookieStyle);
    </script><div class="cookie-notification" style="display: block;">
        <div class="cookie-content">
            <p>We use cookies to enhance your experience</p>
            <div class="cookie-buttons">
                <button class="cookie-decline">Decline</button>
                <button class="cookie-accept">Accept</button>
</div>
        </div>
    </div>

    <!-- Add the modal HTML before the closing body tag -->
    <div id="roadmapModal" class="roadmap-modal">
                            <div class="roadmap-content">
            <span class="close-modal" onclick="closeRoadmap()">×</span>
            <h2>VAE Development Roadmap</h2>
            
            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-date">Q2 2025</div>
                    <div class="timeline-content">
                        <h3>Performance Optimization</h3>
                        <ul>
                            <li>Memory management system improvements</li>
                            <li>Cache optimization for large-scale operations</li>
                            <li>Reduced latency for vector operations</li>
                        </ul>
                        </div>
                </div>

                <div class="timeline-item">
                    <div class="timeline-date">Q3 2025</div>
                    <div class="timeline-content">
                        <h3>Scalability Enhancements</h3>
                        <ul>
                            <li>Improved multi-threading support</li>
                            <li>Enhanced distributed processing capabilities</li>
                            <li>Better resource allocation for large datasets</li>
                        </ul>
                    </div>
                </div>

                <div class="timeline-item">
                    <div class="timeline-date">Q4 2025</div>
                    <div class="timeline-content">
                        <h3>Security and Stability</h3>
                        <ul>
                            <li>Advanced encryption implementation</li>
                            <li>Improved error handling and recovery</li>
                            <li>Enhanced system monitoring tools</li>
                        </ul>
                    </div>
                </div>

                <div class="timeline-item">
                    <div class="timeline-date">Q1 2026</div>
                    <div class="timeline-content">
                        <h3>Developer Experience</h3>
                        <ul>
                            <li>Expanded API documentation</li>
                            <li>New debugging and profiling tools</li>
                            <li>Improved integration examples</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

<style>
.roadmap-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 1000;
    display: none;
    overflow-y: auto;
    backdrop-filter: blur(20px);
}

.roadmap-content {
    max-width: 1200px;
    margin: 40px auto;
    background: linear-gradient(180deg, rgba(20, 20, 20, 0.95) 0%, rgba(10, 10, 10, 0.95) 100%);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 24px;
    font-family: 'Chakra Petch', sans-serif;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
    overflow: hidden;
}

.roadmap-header {
    padding: 40px;
    background: rgba(0, 0, 0, 0.3);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.header-content {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 32px;
}

.header-main h1 {
    font-size: 32px;
    color: #fff;
    margin: 0;
    letter-spacing: 0.5px;
    font-weight: 600;
    background: linear-gradient(90deg, #fff, #00ffcc);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.header-main p {
    color: rgba(255, 255, 255, 0.7);
    margin: 8px 0 0;
    font-size: 16px;
    letter-spacing: 0.3px;
}

.close-modal {
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.6);
    cursor: pointer;
    padding: 8px;
    transition: all 0.3s ease;
}

.close-modal:hover {
    color: #fff;
    transform: rotate(90deg);
}

.roadmap-nav {
    display: flex;
    gap: 2px;
    background: rgba(0, 0, 0, 0.2);
    padding: 2px;
    border-radius: 12px;
    width: fit-content;
}

.nav-item {
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.6);
    padding: 12px 24px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    border-radius: 10px;
    transition: all 0.3s ease;
}

.nav-item.active {
    background: rgba(0, 255, 204, 0.1);
    color: #00ffcc;
}

.roadmap-timeline {
    padding: 40px;
}

.timeline-phase {
    margin-bottom: 60px;
}

.phase-header {
    margin-bottom: 32px;
}

.phase-indicator {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
}

.pulse {
    width: 12px;
    height: 12px;
    background: #00ffcc;
    border-radius: 50%;
    position: relative;
}

.pulse::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: rgba(0, 255, 204, 0.3);
    border-radius: 50%;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% {
        transform: scale(1);
        opacity: 0.8;
    }
    100% {
        transform: scale(3);
        opacity: 0;
    }
}

.status {
    font-size: 14px;
    color: #00ffcc;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.phase-header h2 {
    font-size: 24px;
    color: #fff;
    margin: 0 0 8px;
}

.phase-date {
    font-size: 14px;
    color: rgba(255, 255, 255, 0.5);
}

.milestone-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 24px;
}

.milestone-card {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 24px;
    transition: all 0.3s ease;
}

.milestone-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
    border-color: rgba(0, 255, 204, 0.2);
}

.card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.card-header h3 {
    font-size: 18px;
    color: #fff;
    margin: 0;
}

.progress {
    font-size: 14px;
    color: #00ffcc;
    background: rgba(0, 255, 204, 0.1);
    padding: 4px 12px;
    border-radius: 12px;
    border: 1px solid rgba(0, 255, 204, 0.2);
}

.milestone-tasks {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.milestone-tasks li {
    color: rgba(255, 255, 255, 0.7);
    font-size: 14px;
    padding-left: 24px;
    position: relative;
}

.milestone-tasks li::before {
    content: '';
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
}

.milestone-tasks li.completed {
    color: rgba(255, 255, 255, 0.5);
}

.milestone-tasks li.completed::before {
    background: #00ffcc;
    border-color: #00ffcc;
    content: '✓';
    color: #000;
    font-size: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}

.milestone-tasks li.in-progress::before {
    border-color: #00ffcc;
}

.milestone-card.future {
    opacity: 0.7;
}

.milestone-card.future:hover {
    opacity: 1;
}

@media (max-width: 768px) {
    .roadmap-content {
        margin: 20px;
    }
    
    .milestone-grid {
        grid-template-columns: 1fr;
    }
    
    .roadmap-header {
        padding: 20px;
    }
    
    .header-main h1 {
        font-size: 24px;
    }
}
</style>

<script>
    // Separate function to handle roadmap opening
    function openRoadmap(event) {
        event.preventDefault();
        document.getElementById('roadmapModal').style.display = 'block';
        document.body.style.overflow = 'hidden';
    }

    document.addEventListener('DOMContentLoaded', () => {
        const modal = document.getElementById('roadmapModal');
        const span = document.getElementsByClassName('close-modal')[0];

        // Update modal content with more realistic roadmap
        const timelineContent = `
            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-date">Q2 2025</div>
                    <div class="timeline-content">
                        <h3>Performance Optimization</h3>
                        <ul>
                            <li>Memory management system improvements</li>
                            <li>Cache optimization for large-scale operations</li>
                            <li>Reduced latency for vector operations</li>
                        </ul>
                        </div>
                </div>

                <div class="timeline-item">
                    <div class="timeline-date">Q3 2025</div>
                    <div class="timeline-content">
                        <h3>Scalability Enhancements</h3>
                        <ul>
                            <li>Improved multi-threading support</li>
                            <li>Enhanced distributed processing capabilities</li>
                            <li>Better resource allocation for large datasets</li>
                        </ul>
                    </div>
                </div>

                <div class="timeline-item">
                    <div class="timeline-date">Q4 2025</div>
                    <div class="timeline-content">
                        <h3>Security and Stability</h3>
                        <ul>
                            <li>Advanced encryption implementation</li>
                            <li>Improved error handling and recovery</li>
                            <li>Enhanced system monitoring tools</li>
                        </ul>
                    </div>
                </div>

                <div class="timeline-item">
                    <div class="timeline-date">Q1 2026</div>
                    <div class="timeline-content">
                        <h3>Developer Experience</h3>
                        <ul>
                            <li>Expanded API documentation</li>
                            <li>New debugging and profiling tools</li>
                            <li>Improved integration examples</li>
                        </ul>
                    </div>
                </div>
            </div>`;

        document.querySelector('.roadmap-content').innerHTML = `
            <span class="close-modal" onclick="closeRoadmap()">×</span>
            <h2>VAE Development Roadmap</h2>
            ${timelineContent}
        `;

        // Add global close function
        window.closeRoadmap = function() {
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Close when clicking outside
        window.onclick = function(event) {
            if (event.target == modal) {
                closeRoadmap();
            }
        }
    });
    </script>

    <script>
    // Remove any cursor-related JavaScript
    document.addEventListener('DOMContentLoaded', () => {
        // Update roadmap button click handler to prevent default behavior
        const roadmapButton = document.querySelector('.roadmap-button');
        if (roadmapButton) {
            roadmapButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('roadmapModal').style.display = 'block';
                document.body.style.overflow = 'hidden';
            });
        }
    });
    </script>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // REMOVE ALL CURSOR ELEMENTS
        const cursors = document.querySelectorAll('.cursor, .cursor-follower');
        cursors.forEach(el => el.remove());
        
        // REMOVE ALL CURSOR EVENT LISTENERS
        document.removeEventListener('mousemove', window.updateCursor);
        document.removeEventListener('mousemove', window.updateCursorFollower);
    });
    </script>

<style>
    /* RESET ALL CURSOR STYLES */
    * {
        cursor: initial !important;
    }
    
    a, button {
        cursor: pointer !important;
    }
    
    /* REMOVE ALL CUSTOM CURSOR STYLES */
    .cursor, .cursor-follower {
        display: none !important;
        opacity: 0 !important;
        pointer-events: none !important;
        visibility: hidden !important;
    }
</style>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Add the roadmap button to the main nav links that need to be hidden
        const mainNavLinks = document.querySelectorAll('.main-nav-link, .roadmap-button');
        
        window.addEventListener('scroll', () => {
            const docsContainer = document.querySelector('.docs-container');
            if (docsContainer) {
                const docsTop = docsContainer.offsetTop;
                if (window.scrollY >= docsTop - 100) {
                    mainNavLinks.forEach(link => link.classList.add('hidden'));
                } else {
                    mainNavLinks.forEach(link => link.classList.remove('hidden'));
                }
            }
        });
    });
</script>

<style>
    /* Add styles for main nav links */
    .main-nav-link, .roadmap-button {
        opacity: 1;
        transition: opacity 0.3s ease;
    }

    .main-nav-link.hidden, .roadmap-button.hidden {
        opacity: 0;
        pointer-events: none;
    }
</style>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Specifically include the roadmap button in the selection
        const navLinks = document.querySelectorAll('.nav-link, .roadmap-button');
        
        window.addEventListener('scroll', () => {
            const docsContainer = document.querySelector('.docs-container');
            if (docsContainer) {
                const docsTop = docsContainer.offsetTop;
                const scrollPosition = window.scrollY;
                
                if (scrollPosition >= docsTop - 100) {
                    navLinks.forEach(link => {
                        link.style.opacity = '0';
                        link.style.pointerEvents = 'none';
                    });
                } else {
                    navLinks.forEach(link => {
                        link.style.opacity = '1';
                        link.style.pointerEvents = 'auto';
                    });
                }
            }
        });
    });
</script>

<style>
    .nav-link, .roadmap-button {
        transition: opacity 0.3s ease;
    }
</style>

<script>
    // Update scroll event listener
    document.addEventListener('DOMContentLoaded', () => {
        const mainNavLinks = document.querySelectorAll('.main-nav-link');
        
        window.addEventListener('scroll', () => {
            const docsContainer = document.querySelector('.docs-container');
            if (docsContainer) {
                const docsTop = docsContainer.offsetTop;
                if (window.scrollY >= docsTop - 100) {
                    mainNavLinks.forEach(link => {
                        link.classList.add('hidden');
                        link.style.display = 'none'; // Ensure they're removed from flow
                    });
                } else {
                    mainNavLinks.forEach(link => {
                        link.classList.remove('hidden');
                        link.style.display = ''; // Restore display
                    });
                }
            }
        });
    });
</script>


<div class="scroll-indicator-container">
                <div class="scroll-label">Scroll</div>
                <div class="scroll-progress">
                    <div class="scroll-progress-bar"></div>
                    <div class="scroll-marker"></div>
                </div>
                <div class="scroll-label">Progress</div>
            </div></body></html>